<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>ELECTRO RECOVERY</title>
    <style>
        :root {
            --yellow-glow: #ffcc00;
            --indigo-glow: #3b5998;
            --accent-yellow: #ffcc00;
            --neon-red: #ff0044;
        }
        * {
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }
        html {
            height: 100%;
            overflow: hidden;
        }
        
        body {
            background: #050508;
            color: white;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            height: 100%;
            min-height: 100vh;
            min-height: -webkit-fill-available;
            margin: 0;
            padding: 0;
            font-family: 'Inter', 'Segoe UI', system-ui, sans-serif;
            overflow: hidden;
            touch-action: none;
            position: fixed;
            width: 100%;
        }

        .header-ui {
            width: 100%;
            min-height: 60px;
            max-height: 80px;
            height: 12vh;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 15px;
            background: linear-gradient(to bottom, rgba(255,255,255,0.03) 0%, transparent 100%);
            border-bottom: 1px solid rgba(255,255,255,0.08);
            z-index: 10;
            flex-shrink: 0;
            padding: 5px 10px;
        }

        .stat-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            min-width: 60px;
            flex: 0 1 auto;
        }

        .score-label { 
            font-size: 8px; 
            color: rgba(255,255,255,0.4); 
            text-transform: uppercase; 
            letter-spacing: 1px;
            margin-bottom: 1px;
            white-space: nowrap;
        }
        .score-val { 
            font-size: clamp(18px, 5vw, 28px);
            font-weight: 900; 
            font-variant-numeric: tabular-nums; 
        }

        #rank-display {
            font-size: clamp(16px, 4.5vw, 24px);
            font-weight: 900;
            font-style: italic;
        }
        
        #combo-group {
            transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            transform: scale(0);
            opacity: 0;
        }
        #combo-group.active {
            transform: scale(1);
            opacity: 1;
        }
        
        .rainbow-text {
            animation: rainbow 2s linear infinite;
        }
        @keyframes rainbow {
            0% { color: #ff0000; }
            20% { color: #ffff00; }
            40% { color: #00ff00; }
            60% { color: #00ffff; }
            80% { color: #0000ff; }
            100% { color: #ff00ff; }
        }

        #game-container {
            position: relative;
            width: 100%;
            flex: 1; 
            min-height: 0;
            background: #000;
            overflow: hidden;
            display: flex;
        }

        canvas {
            background: radial-gradient(circle at center, #0e0e12 0%, #000 100%);
            width: 100%;
            height: 100%;
            display: block;
            touch-action: none;
        }
        
        #overlay-screen {
            position: absolute;
            inset: 0;
            background: rgba(0,0,0,0.92);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
            transition: opacity 0.4s;
            backdrop-filter: blur(15px);
            padding: 20px;
        }
        h1 { 
            font-size: clamp(32px, 10vw, 48px);
            font-weight: 900; 
            margin: 0; 
            letter-spacing: -1px; 
            text-align: center; 
            line-height: 1.1;
            padding: 0 10px;
        }
        
        .rank-large {
            font-size: clamp(48px, 15vw, 80px);
            font-weight: 900;
            margin: 10px 0;
        }

        .result-stats {
            display: flex;
            gap: 10px;
            margin: 10px 0;
            padding: 10px 15px;
            background: rgba(255,255,255,0.05);
            border-radius: 8px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .res-item {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .res-label {
            font-size: 9px;
            color: rgba(255,255,255,0.4);
            text-transform: uppercase;
        }

        .res-val {
            font-size: clamp(16px, 4vw, 20px);
            font-weight: 900;
        }

        .btn {
            padding: 12px 30px;
            font-size: clamp(14px, 3.5vw, 18px);
            background: #fff;
            color: #000;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 900;
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-top: 10px;
        }
        .hidden { opacity: 0 !important; pointer-events: none !important; }

        /* Tablet/Desktop scale up */
        @media (min-width: 768px) {
            .header-ui { 
                height: 15vh;
                max-height: 100px; 
                gap: 60px; 
            }
            .score-val { font-size: 48px; }
            #rank-display { font-size: 32px; }
            h1 { font-size: 72px; }
            .rank-large { font-size: 120px; }
            .res-val { font-size: 32px; }
            .stat-group { min-width: 80px; }
        }
        
        /* Small mobile optimization */
        @media (max-width: 380px) {
            .header-ui {
                gap: 8px;
                padding: 5px;
            }
            .stat-group {
                min-width: 50px;
            }
            .score-label {
                font-size: 7px;
                letter-spacing: 0.5px;
            }
        }
    </style>
</head>
<body>

    <header class="header-ui">
        <div class="stat-group">
            <div class="score-label">SCORE</div>
            <div id="score" class="score-val">0</div>
        </div>
        <div class="stat-group">
            <div class="score-label">RANK</div>
            <div id="rank-display">C</div>
        </div>
        <div id="combo-group" class="stat-group">
            <div class="score-label">COMBO</div>
            <div id="combo" class="score-val" style="color: var(--accent-yellow);">0</div>
        </div>
    </header>

    <div id="game-container">
        <div id="overlay-screen">
            <h1 id="status-title">ELECTRO<br>RECOVERY</h1>
            
            <div id="result-box" class="hidden" style="display: flex; flex-direction: column; align-items: center; width: 100%;">
                <div id="final-rank-box" class="rank-large">C</div>
                <div class="result-stats">
                    <div class="res-item">
                        <div class="res-label">HIGH SCORE</div>
                        <div id="res-highscore" class="res-val" style="color: #ffd700;">0</div>
                    </div>
                    <div class="res-item">
                        <div class="res-label">MAX COMBO</div>
                        <div id="res-maxcombo" class="res-val" style="color: var(--accent-yellow);">0</div>
                    </div>
                </div>
                <div class="result-stats">
                    <div class="res-item">
                        <div class="res-label">HIJIKI</div>
                        <div id="res-yellow" class="res-val" style="color: var(--yellow-glow);">0</div>
                    </div>
                    <div class="res-item">
                        <div class="res-label">LOZ</div>
                        <div id="res-indigo" class="res-val" style="color: #5c7cfa;">0</div>
                    </div>
                    <div class="res-item">
                        <div class="res-label">TOTAL</div>
                        <div id="res-total" class="res-val">0</div>
                    </div>
                </div>
                <div style="margin-top: 10px; padding: 8px 16px; background: rgba(255,255,255,0.05); border-radius: 4px;">
                    <div class="res-label" style="margin-bottom: 4px;">DEVICE</div>
                    <div id="res-device" class="res-val" style="font-size: clamp(14px, 3.5vw, 18px); color: #aaa;">-</div>
                </div>
            </div>

            <p id="status-msg" style="color: #ccc; margin: 10px 0 20px; text-align: center; max-width: 90%; line-height: 1.5; font-size: clamp(12px, 3vw, 14px); padding: 0 15px;">
                „Éâ„É©„ÉÉ„Ç∞„Åó„Å¶Ëâ≤„Çí‰ªïÂàÜ„Åë„Çç„ÄÇ<br>„Éü„Çπ„ÅØË®±„Åï„Çå„Å™„ÅÑ„ÄÇ
            </p>
            <button class="btn" onclick="startGame()" id="action-btn">INITIALIZE</button>
        </div>
        <canvas id="game"></canvas>
    </div>

<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
const scoreEl = document.getElementById("score");
const comboEl = document.getElementById("combo");
const rankEl = document.getElementById("rank-display");
const comboGroup = document.getElementById("combo-group");
const overlay = document.getElementById("overlay-screen");
const statusTitle = document.getElementById("status-title");
const statusMsg = document.getElementById("status-msg");
const finalRankBox = document.getElementById("final-rank-box");
const resultBox = document.getElementById("result-box");
const actionBtn = document.getElementById("action-btn");

// ===== Asset Loading =====
const bombSprite = new Image();
bombSprite.src = "../resource/HjkBom.png"; 

let imgReady = false;
bombSprite.onload = () => { imgReady = true; };

// ===== Constants & Config =====
let ZONES = {};
const GRID = { padding: 35 }; 
const BOMB_RADIUS = 22;
const TILE_SIZE = 64; 
const DRAW_SIZE = 54; 
const HIT_SLOP = 50; 
const VISUAL_CAPACITY = 100;
const MERGE_DISTANCE = 100;
const BASE_SIZE_LEVELS = [
    { scale: 1.0, fuseBonus: 0, scoreMultiplier: 1, name: "Normal", dragWeight: 1.0 },
    { scale: 1.4, fuseBonus: 2000, scoreMultiplier: 5, name: "Big", dragWeight: 1.0 },
    { scale: 1.8, fuseBonus: 3000, scoreMultiplier: 12, name: "Huge", dragWeight: 0.7 },
    { scale: 2.2, fuseBonus: 4000, scoreMultiplier: 25, name: "Mega", dragWeight: 0.4 }
];

// ÂãïÁöÑ„Å´„Çµ„Ç§„Ç∫„É¨„Éô„É´„ÇíÂèñÂæó„Åô„ÇãÈñ¢Êï∞
function getSizeLevel(level) {
    if (level < BASE_SIZE_LEVELS.length) {
        return BASE_SIZE_LEVELS[level];
    }
    // „É¨„Éô„É´4‰ª•Èôç„ÅØÂãïÁöÑ„Å´ÁîüÊàê
    const extraLevels = level - BASE_SIZE_LEVELS.length + 1;
    return {
        scale: 2.2 + (extraLevels * 0.3),
        fuseBonus: 4000 + (extraLevels * 1000),
        scoreMultiplier: 25 + (extraLevels * 10),
        name: `Ultra${extraLevels}`,
        dragWeight: Math.max(0.1, 0.4 - (extraLevels * 0.05))
    };
}

const MERGE_COOLDOWN = 300; 

// ===== Game State =====
let gameState = 'START'; 
let bombs = [];
let sortedBombs = { yellow: [], indigo: [] };
let finalCounts = { yellow: 0, indigo: 0 };
let particles = [];
let floatingTexts = [];
let mergeEffects = [];
let dragging = null;
let mousePos = { x: 0, y: 0 };
let lastMousePos = { x: 0, y: 0 };
let touchOffset = { x: 0, y: 0 };
let score = 0;
let combo = 0;
let maxCombo = 0;
let highScore = 0;
let lastMatchTime = 0;
let lastSpawn = 0;
let spawnInterval = 1800;
let shakeTime = 0;
let vacuums = []; // ÊéÉÈô§Ê©ü„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„ÅÆÈÖçÂàó
let lastVacuumSpawn = 0;
let beakers = []; // üß™„Éì„Éº„Ç´„Éº„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„ÅÆÈÖçÂàó
let autoMergeLevel = 0; // Ê∞∏Á∂öÁöÑ„Å™Ëá™ÂãïÂêà‰Ωì„É¨„Éô„É´ (0=„Å™„Åó, 1=Lv1ÂêåÂ£´, 2=Lv2ÂêåÂ£´...)
let beakerSchedule = [10000, 20000, 30000, 40000, 50000]; // üß™Âá∫Áèæ„Çπ„Ç±„Ç∏„É•„Éº„É´
let currentBeakerIndex = 0; // Ê¨°„Å´Âá∫Áèæ„Åô„Çãüß™„ÅÆ„Ç§„É≥„Éá„ÉÉ„ÇØ„Çπ

// ===== Rank System =====
function getRank(s) {
    if (s < 1000) return { name: "C", color: "#aaa" };
    if (s < 3000) return { name: "B", color: "#8f8" };
    if (s < 6000) return { name: "A", color: "#4af" };
    if (s < 12000) return { name: "S", color: "#f5f" };
    if (s < 20000) return { name: "SS", color: "#f22" };
    if (s < 30000) return { name: "SSS", color: "#ff0" };
    if (s < 45000) return { name: "SSS+", color: "#fff" };
    if (s < 65000) return { name: "X", color: "#ff8c00" }; 
    if (s < 90000) return { name: "XX", color: "#00ffcc" };
    if (s < 120000) return { name: "XXX", color: "#ff00ff" };
    const uNum = Math.floor((s - 120000) / 40000) + 1;
    return { name: `U${uNum}`, color: "#fff", special: true };
}

function updateRankUI() {
    const r = getRank(score);
    rankEl.innerText = r.name;
    if (r.special) {
        rankEl.style.background = "linear-gradient(45deg, #ff0, #f0f, #0ff)";
        rankEl.style.webkitTextFillColor = "transparent";
        rankEl.style.webkitBackgroundClip = "text";
        rankEl.classList.add('rainbow-text');
    } else {
        rankEl.style.background = "none";
        rankEl.style.webkitTextFillColor = r.color;
        rankEl.classList.remove('rainbow-text');
    }
}

// ===== Setup =====
function resize() {
    const container = document.getElementById("game-container");
    const dpr = window.devicePixelRatio || 1;
    const rect = container.getBoundingClientRect();
    
    canvas.width = rect.width * dpr;
    canvas.height = rect.height * dpr;
    ctx.scale(dpr, dpr);
    
    // UI layout scaling for mobile
    const logicalWidth = rect.width;
    const logicalHeight = rect.height;

    // PCÁîªÈù¢„Åß„ÅØ‰∏≠Â§Æ„ÅÆÊπß„ÅçÁ©∫Èñì„ÇíÂõ∫ÂÆö„Çµ„Ç§„Ç∫„Å´
    const isPC = logicalWidth >= 768;
    let zoneW, spawnAreaWidth;
    
    if (isPC) {
        // PC: ‰ªïÂàÜ„Åë„Çæ„Éº„É≥„ÅØÁîªÈù¢Á´Ø„Åã„ÇâÊπß„ÅçÂ†¥ÊâÄ„ÅÆÂ¢ÉÁïå„Åæ„Åß
        spawnAreaWidth = 800; // ‰∏≠Â§Æ„ÅÆÊπß„ÅçÁ©∫Èñì„ÅÆÂπÖ„Çí800px„Å´Êã°Â§ß
        const spawnAreaLeft = (logicalWidth - spawnAreaWidth) / 2;
        const spawnAreaRight = (logicalWidth + spawnAreaWidth) / 2;
        
        zoneW = spawnAreaLeft; // Â∑¶Á´Ø„Åã„ÇâÊπß„ÅçÂ†¥ÊâÄ„Åæ„Åß„ÅÆÂπÖ
        
        ZONES = {
            yellow: { x: 0, y: 0, w: spawnAreaLeft, h: logicalHeight, color: '#ffcc00', glow: 'rgba(255, 204, 0, 0.15)' },
            indigo: { x: spawnAreaRight, y: 0, w: logicalWidth - spawnAreaRight, h: logicalHeight, color: '#3b5998', glow: 'rgba(59, 89, 152, 0.15)' }
        };
    } else {
        // „É¢„Éê„Ç§„É´: ‰ªïÂàÜ„Åë„Çæ„Éº„É≥„ÇíÁîªÈù¢Â§ñ„Åæ„ÅßÊã°ÂºµÔºàÊÖ£ÊÄßÂØæÁ≠ñÔºâ
        zoneW = Math.min(logicalWidth * 0.28, 180);
        const marginY = Math.max(20, logicalHeight * 0.08);
        const zoneH = logicalHeight - (marginY * 2);
        
        // Âà§ÂÆö„Ç®„É™„Ç¢„ÇíÁîªÈù¢Â§ñ500px„Åæ„ÅßÊã°Âºµ
        const extendArea = 500;
        
        ZONES = {
            yellow: { 
                x: -extendArea, 
                y: -extendArea, 
                w: zoneW + extendArea, 
                h: logicalHeight + (extendArea * 2), 
                visualX: 0,
                visualY: marginY,
                visualW: zoneW,
                visualH: zoneH,
                color: '#ffcc00', 
                glow: 'rgba(255, 204, 0, 0.15)' 
            },
            indigo: { 
                x: logicalWidth - zoneW, 
                y: -extendArea, 
                w: zoneW + extendArea, 
                h: logicalHeight + (extendArea * 2),
                visualX: logicalWidth - zoneW,
                visualY: marginY,
                visualW: zoneW,
                visualH: zoneH,
                color: '#3b5998', 
                glow: 'rgba(59, 89, 152, 0.15)' 
            }
        };
    }

    // Update grid padding
    GRID.padding = Math.max(25, Math.min(35, zoneW / 4));
}

// Mobile viewport height fix
function setVH() {
    const vh = window.innerHeight * 0.01;
    document.documentElement.style.setProperty('--vh', `${vh}px`);
}

window.addEventListener('resize', () => {
    setVH();
    resize();
});
window.addEventListener('orientationchange', () => {
    setTimeout(() => {
        setVH();
        resize();
    }, 300);
});

setVH();
resize();

// ===== FX Utils =====
function createText(x, y, text, color, size = 24) {
    floatingTexts.push({ x, y, text, color, life: 1.0, vy: -1.5, size });
}

function createParticles(x, y, color, count = 10, speed = 8) {
    for (let i = 0; i < count; i++) {
        const ang = Math.random() * Math.PI * 2;
        const s = Math.random() * speed;
        particles.push({
            x, y,
            vx: Math.cos(ang) * s,
            vy: Math.sin(ang) * s,
            r: Math.random() * 3 + 1,
            color,
            life: 1.0,
            decay: 0.03 + Math.random() * 0.03
        });
    }
}

function applyShake(intensity = 10) {
    shakeTime = intensity;
}

function createBigExplosion(x, y) {
    applyShake(15);
    for (let i = 0; i < 30; i++) {
        const ang = Math.random() * Math.PI * 2;
        const s = Math.random() * 20;
        particles.push({
            x, y,
            vx: Math.cos(ang) * s,
            vy: Math.sin(ang) * s,
            r: Math.random() * 6 + 1,
            color: Math.random() > 0.3 ? "#ff4400" : (Math.random() > 0.5 ? "#ffcc00" : "#fff"),
            life: 1.0,
            decay: 0.02
        });
    }
}

function createMergeEffect(x, y, color) {
    mergeEffects.push({
        x, y,
        color,
        radius: 10,
        maxRadius: 60,
        life: 1.0
    });
    applyShake(8);
    createParticles(x, y, color, 20, 12);
}

async function triggerChainExplosionSequence(wrongZoneType, wrongBomb, reason) {
    if (gameState === 'EXPLODING' || gameState === 'GAMEOVER') return;
    gameState = 'EXPLODING';
    dragging = null; 

    finalCounts.yellow = sortedBombs.yellow.length;
    finalCounts.indigo = sortedBombs.indigo.length;

    sortedBombs[wrongZoneType].push(wrongBomb);
    const bombIdx = bombs.indexOf(wrongBomb);
    if (bombIdx > -1) bombs.splice(bombIdx, 1);

    const targetList = sortedBombs[wrongZoneType];
    ZONES[wrongZoneType].glow = 'rgba(255, 0, 40, 0.7)';

    const explosionLimit = Math.min(targetList.length, VISUAL_CAPACITY);
    for (let i = 0; i < explosionLimit; i++) {
        const b = targetList.pop();
        if (b) createBigExplosion(b.x, b.y);
        await new Promise(r => setTimeout(r, 40));
    }
    sortedBombs[wrongZoneType] = [];

    for (let i = bombs.length - 1; i >= 0; i--) {
        const b = bombs[i];
        createBigExplosion(b.x, b.y);
        bombs.splice(i, 1);
        if (i % 3 === 0) await new Promise(r => setTimeout(r, 10));
    }

    setTimeout(() => doGameOver(reason), 800);
}

// ===== Logic =====
function spawnBomb() {
    const logicalW = canvas.width / (window.devicePixelRatio || 1);
    const logicalH = canvas.height / (window.devicePixelRatio || 1);

    const isIndigo = Math.random() < 0.5;
    const type = isIndigo ? "indigo" : "yellow";
    const spriteIndex = isIndigo ? 1 : 0;
    
    // Á∑©„ÇÑ„Åã„Å™‰∏ä„Åã„Çâ„ÅÆ„Çπ„Éù„Éº„É≥Á¢∫Áéá‰∏äÊòá
    const topSpawnChance = score < 2000 ? 0.2 : Math.min(0.5, (score - 2000) / 20000);
    const spawnFromTop = Math.random() < topSpawnChance;
    
    const startY = spawnFromTop ? -40 : logicalH + 40;
    // ÈÄüÂ∫¶„ÇÇÁ∑©„ÇÑ„Åã„Å´‰∏äÊòá
    const baseSpeed = 2.0 + score/12000;
    const vyBase = spawnFromTop ? baseSpeed : -baseSpeed;

    // „Çπ„Éù„Éº„É≥‰ΩçÁΩÆ„Çí‰∏≠Â§Æ„Ç®„É™„Ç¢„Å´ÈôêÂÆöÔºàPCÂØæÂøúÔºâ
    const isPC = logicalW >= 768;
    let spawnAreaWidth;
    
    if (isPC) {
        spawnAreaWidth = 800;
    } else {
        // „É¢„Éê„Ç§„É´: ‰∏°„Çµ„Ç§„Éâ„ÅÆ„Çæ„Éº„É≥ÂπÖ„ÇíÂèñÂæó
        const zoneW = Math.min(logicalW * 0.28, 180);
        spawnAreaWidth = logicalW - (zoneW * 2);
    }
    
    bombs.push({
        x: logicalW / 2 + (Math.random() - 0.5) * spawnAreaWidth,
        y: startY,
        vx: (Math.random() - 0.5) * (2.0 + score/15000),
        vy: vyBase + (Math.random() - 0.5) * 1.0,
        r: BOMB_RADIUS,
        type,
        spriteIndex, 
        born: Date.now(),
        fuseTime: Math.max(5000, 14000 - (score * 0.25)),
        wobble: Math.random() * Math.PI,
        color: type === 'yellow' ? '#ffcc00' : '#3b5998',
        sizeLevel: 0
    });
}

function getSortedPosition(type, index) {
    const zone = ZONES[type];
    // „É¢„Éê„Ç§„É´„Åß„ÅØvisual„Éó„É≠„Éë„ÉÜ„Ç£„Çí‰ΩøÁî®
    const zoneX = zone.visualX !== undefined ? zone.visualX : zone.x;
    const zoneY = zone.visualY !== undefined ? zone.visualY : zone.y;
    const zoneW = zone.visualW !== undefined ? zone.visualW : zone.w;
    
    const cols = Math.floor((zoneW - 20) / GRID.padding);
    const visualIndex = index % VISUAL_CAPACITY;
    
    const col = visualIndex % Math.max(1, cols);
    const row = Math.floor(visualIndex / Math.max(1, cols));
    
    const startX = zoneX + 25;
    const startY = zoneY + 40;
    return {
        x: startX + (col * GRID.padding),
        y: startY + (row * GRID.padding)
    };
}

function checkMerge(draggedBomb) {
    if (!draggedBomb) return null;
    
    for (let i = bombs.length - 1; i >= 0; i--) {
        const b = bombs[i];
        if (b === draggedBomb) continue;
        
        const dist = Math.hypot(b.x - draggedBomb.x, b.y - draggedBomb.y);
        const levelData = getSizeLevel(b.sizeLevel);
        const mergeRadius = MERGE_DISTANCE * levelData.scale;
        
        // Âêå„Åò„Çø„Ç§„Éó„ÄÅÂêå„Åò„Çµ„Ç§„Ç∫„É¨„Éô„É´„Å™„ÇâÂêà‰ΩìÂèØËÉΩ
        // üß™ÂèñÂæóÂâç: ÊâãÂãï„Éâ„É©„ÉÉ„Ç∞„ÅßÂêà‰ΩìÔºà„Ç≥„É≥„ÉúÂçäÊ∏õÔºâ
        // üß™ÂèñÂæóÂæå: Ëá™ÂãïÂêà‰Ωì„ÇÇ„Åß„Åç„ÇãÔºà„Ç≥„É≥„ÉúÁ∂≠ÊåÅÔºâ
        if (dist < mergeRadius && 
            b.type === draggedBomb.type && 
            b.sizeLevel === draggedBomb.sizeLevel) {
            return { target: b, index: i };
        }
    }
    return null;
}

function mergeBombs(b1, b2, b2Index) {
    const newLevel = b1.sizeLevel + 1;
    const levelData = getSizeLevel(newLevel);
    
    bombs.splice(b2Index, 1);
    
    b1.sizeLevel = newLevel;
    b1.born = Date.now();
    b1.fuseTime = Math.max(4000, 14000 - (score * 0.3)) + levelData.fuseBonus;
    
    const mergeX = (b1.x + b2.x) / 2;
    const mergeY = (b1.y + b2.y) / 2;
    b1.x = mergeX;
    b1.y = mergeY;
    
    // „Ç≥„É≥„Éú„ÇíÂçäÊ∏õ
    if (combo > 0) {
        combo = Math.floor(combo / 2);
        comboEl.innerText = combo;
        if (combo <= 1) {
            comboGroup.classList.remove('active');
        }
    }
    
    createMergeEffect(mergeX, mergeY, b1.color);
    
    return b1;
}

const onStart = e => {
    if(gameState !== 'PLAYING') return; 
    const p = getPos(e);
    
    // üß™„Éì„Éº„Ç´„Éº„ÅÆ„ÇØ„É™„ÉÉ„ÇØÂà§ÂÆö
    for (let i = beakers.length - 1; i >= 0; i--) {
        const beaker = beakers[i];
        const dist = Math.hypot(p.x - beaker.x, p.y - beaker.y);
        if (dist < beaker.radius + 20) {
            // Ê∞∏Á∂öÁöÑ„Å´Ëá™ÂãïÂêà‰Ωì„É¨„Éô„É´„Ç¢„ÉÉ„Éó
            autoMergeLevel = beaker.level;
            currentBeakerIndex++; // Ê¨°„ÅÆ„Çπ„Ç±„Ç∏„É•„Éº„É´„Å∏
            
            createText(beaker.x, beaker.y - 40, `AUTO MERGE Lv${autoMergeLevel} UNLOCKED!`, "#ff66ff", 28);
            createText(beaker.x, beaker.y + 40, `PERMANENT UPGRADE`, "#fff", 20);
            applyShake(12);
            
            // „Éì„Éº„Ç´„Éº„ÇíÂâäÈô§
            beakers.splice(i, 1);
            return;
        }
    }
    
    // ÊéÉÈô§Ê©ü„ÅÆ„ÇØ„É™„ÉÉ„ÇØÂà§ÂÆö
    for (let i = vacuums.length - 1; i >= 0; i--) {
        const vac = vacuums[i];
        const dist = Math.hypot(p.x - vac.x, p.y - vac.y);
        if (dist < vac.radius + 20) {
            // Âë®Âõ≤„ÅÆ„Éú„É†„ÇíÂê∏Âèé
            const absorbRadius = 250;
            let absorbed = 0;
            
            for (let j = bombs.length - 1; j >= 0; j--) {
                const b = bombs[j];
                const bombDist = Math.hypot(b.x - vac.x, b.y - vac.y);
                if (bombDist < absorbRadius) {
                    // Âê∏Âèé„Ç®„Éï„Çß„ÇØ„Éà
                    createParticles(b.x, b.y, b.color, 15, 10);
                    bombs.splice(j, 1);
                    absorbed++;
                }
            }
            
            // ‰ªñ„ÅÆÊéÉÈô§Ê©ü„ÇÇÂê∏Âèé
            for (let j = vacuums.length - 1; j >= 0; j--) {
                if (i === j) continue;
                const vac2 = vacuums[j];
                const vacDist = Math.hypot(vac2.x - vac.x, vac2.y - vac.y);
                if (vacDist < absorbRadius) {
                    createParticles(vac2.x, vac2.y, "#44ff44", 20, 12);
                    vacuums.splice(j, 1);
                    if (j < i) i--; // „Ç§„É≥„Éá„ÉÉ„ÇØ„ÇπË™øÊï¥
                    absorbed++;
                }
            }
            
            if (absorbed > 0) {
                createText(vac.x, vac.y - 40, `ABSORBED ${absorbed}!`, "#44ff44", 28);
                applyShake(10);
            }
            
            // ‰ΩøÁî®„Åó„ÅüÊéÉÈô§Ê©ü„ÇíÂâäÈô§
            vacuums.splice(i, 1);
            return;
        }
    }
    
    // „Éú„É†„ÅÆ„Éâ„É©„ÉÉ„Ç∞Âà§ÂÆö
    let target = null;
    let minDist = HIT_SLOP + BOMB_RADIUS;
    let targetIdx = -1;
    
    for(let i=bombs.length-1; i>=0; i--) {
        const b = bombs[i];
        const levelData = getSizeLevel(b.sizeLevel);
        // Â§ß„Åç„ÅÑ„Éú„É†„Åª„Å©HIT_SLOP„ÇíÊ∏õ„Çâ„Åó„Å¶Âø†ÂÆü„Å™Âà§ÂÆö„Å´
        const slopReduction = Math.min(b.sizeLevel * 10, HIT_SLOP - 10); // ÊúÄÂ§ß40ÂâäÊ∏õ
        const adjustedSlop = Math.max(10, HIT_SLOP - slopReduction);
        const adjustedRadius = (b.r * levelData.scale) + adjustedSlop;
        const d = Math.hypot(p.x - b.x, p.y - b.y);
        if(d < adjustedRadius) { 
            minDist = d; 
            target = b; 
            targetIdx = i; 
            break;
        }
    }
    if(target) {
        dragging = target;
        touchOffset.x = p.x - target.x;
        touchOffset.y = p.y - target.y;
        dragging.vx = 0; dragging.vy = 0;
        bombs.splice(targetIdx, 1);
        bombs.push(target);
    }
};

function checkZoneEntry(b) {
    const withinXYellow = b.x >= ZONES.yellow.x && b.x <= ZONES.yellow.x + ZONES.yellow.w;
    const withinXIndigo = b.x >= ZONES.indigo.x && b.x <= ZONES.indigo.x + ZONES.indigo.w;
    const withinY = b.y >= ZONES.yellow.y && b.y <= ZONES.yellow.y + ZONES.yellow.h;
    
    if (withinY && (withinXYellow || withinXIndigo)) {
        const zoneType = withinXYellow ? 'yellow' : 'indigo';
        
        if (b.type === zoneType) {
            const index = sortedBombs[zoneType].length;
            const targetPos = getSortedPosition(zoneType, index);
            b.x = targetPos.x; b.y = targetPos.y;

            sortedBombs[zoneType].push(b);
            const bombIdx = bombs.indexOf(b);
            if (bombIdx > -1) bombs.splice(bombIdx, 1);

            const levelData = getSizeLevel(b.sizeLevel);
            
            if (b.sizeLevel > 0) {
                // Â§ß„Åç„ÅÑ„Éú„Éº„É´„Åß„ÇÇ„Ç≥„É≥„Éú„ÅØÁ∂ôÁ∂ö
                combo++;
                lastMatchTime = Date.now();
                if (combo > maxCombo) maxCombo = combo;
                const megaPoints = 100 * levelData.scoreMultiplier;
                score += megaPoints;
                if (combo > 1) comboGroup.classList.add('active');
                createText(b.x, b.y, `+${megaPoints}`, "#ffff00", 32);
                createText(b.x, b.y - 40, `${levelData.name.toUpperCase()} BONUS!`, "#fff", 20);
                applyShake(12);
            } else {
                combo++;
                lastMatchTime = Date.now();
                if (combo > maxCombo) maxCombo = combo;
                const points = Math.floor(10 * (1 + combo * 0.1));
                score += points;
                if (combo > 1) comboGroup.classList.add('active');
                createText(b.x, b.y, `+${points}`, ZONES[zoneType].color);
            }
            
            const oldRank = getRank(score - (b.sizeLevel > 0 ? 100 * levelData.scoreMultiplier : Math.floor(10 * (1 + combo * 0.1)))).name;
            scoreEl.innerText = score;
            comboEl.innerText = combo;
            updateRankUI();

            if (oldRank !== getRank(score).name) {
                const logicalW = canvas.width / (window.devicePixelRatio || 1);
                const logicalH = canvas.height / (window.devicePixelRatio || 1);
                createText(logicalW/2, logicalH/2, "RANK UP!", "#fff", 40);
                applyShake(10);
            }

            createParticles(b.x, b.y, ZONES[zoneType].color, b.sizeLevel > 0 ? 15 : 8);
            return true;
        } else {
            triggerChainExplosionSequence(zoneType, b, "ÂéüÂõ†ÔºöÊâ±„ÅÑÊñπ„ÇíÈñìÈÅï„Åà„ÅüÊú´Ë∑Ø");
            return false;
        }
    }
    return false;
}

function update(ts) {
    if (gameState !== 'PLAYING' && gameState !== 'EXPLODING') return;

    const logicalW = canvas.width / (window.devicePixelRatio || 1);
    const logicalH = canvas.height / (window.devicePixelRatio || 1);

    // „Çà„ÇäÁ∑©„ÇÑ„Åã„Å™„Çπ„Éù„Éº„É≥ÈñìÈöî„ÅÆÊ∏õÂ∞ë
    if (gameState === 'PLAYING' && ts - lastSpawn > spawnInterval) {
        spawnBomb();
        lastSpawn = ts;
        spawnInterval = Math.max(400, 1200 - (score * 0.05));
    }

    // üß™„Éì„Éº„Ç´„Éº„ÅÆ„Çπ„Éù„Éº„É≥Ôºà„Çπ„Ç≥„Ç¢„ÅåÈñæÂÄ§„ÇíË∂Ö„Åà„Åü„ÇâÔºâ
    if (gameState === 'PLAYING' && beakers.length === 0 && currentBeakerIndex < beakerSchedule.length) {
        const threshold = beakerSchedule[currentBeakerIndex];
        if (score >= threshold) {
            const isPC = logicalW >= 768;
            let spawnAreaWidth;
            
            if (isPC) {
                spawnAreaWidth = 800;
            } else {
                // „É¢„Éê„Ç§„É´: ‰∏°„Çµ„Ç§„Éâ„ÅÆ„Çæ„Éº„É≥ÂπÖ„ÇíÂèñÂæó
                const zoneW = Math.min(logicalW * 0.28, 180);
                spawnAreaWidth = logicalW - (zoneW * 2);
            }
            
            // ÁèæÂú®„ÅÆautoMergeLevel„Å´Âü∫„Å•„ÅÑ„Å¶Ê¨°„ÅÆ„É¨„Éô„É´„ÇíÊ±∫ÂÆö
            const nextLevel = autoMergeLevel + 1;
            
            beakers.push({
                x: logicalW / 2 + (Math.random() - 0.5) * spawnAreaWidth * 0.5,
                y: -50,
                vy: 4.0, // „Çà„ÇäÈÄü„Åè
                radius: 30,
                born: Date.now(),
                level: nextLevel,
                scheduleIndex: currentBeakerIndex
            });
        }
    }

    // üß™„Éì„Éº„Ç´„Éº„ÅÆÁßªÂãïÔºà‰∏ä„Åã„Çâ‰∏ã„Å∏Áõ¥Á∑öÁöÑ„Å´ËêΩ„Å°„ÇãÔºâ
    for (let i = beakers.length - 1; i >= 0; i--) {
        const beaker = beakers[i];
        beaker.y += beaker.vy;
        
        // ÁîªÈù¢‰∏ã„Å´Âá∫„Åü„ÇâÂâäÈô§„Åó„ÄÅÊ¨°„ÅÆ„Çπ„Ç±„Ç∏„É•„Éº„É´„Å´ÈÄ≤„ÇÄÔºàÂèñ„ÇäÈÄÉ„ÅóÔºâ
        if (beaker.y > logicalH + 100) {
            beakers.splice(i, 1);
            // 5000ÁÇπÂæå„Å´ÂÜçÂá∫Áèæ
            beakerSchedule.push(score + 5000);
        }
    }

    // ÊéÉÈô§Ê©ü„ÅÆ„Çπ„Éù„Éº„É≥Ôºà20ÁßíÔΩû40Áßí„Å´1ÂõûÔºâ
    if (gameState === 'PLAYING' && ts - lastVacuumSpawn > 20000 + Math.random() * 20000) {
        const spawnFromTop = Math.random() < 0.5;
        const startY = spawnFromTop ? -50 : logicalH + 50;
        const baseSpeed = 1.5;
        const vyBase = spawnFromTop ? baseSpeed : -baseSpeed;
        
        // „Çπ„Éù„Éº„É≥‰ΩçÁΩÆ„Çí‰∏≠Â§Æ„Ç®„É™„Ç¢„Å´ÈôêÂÆöÔºàPCÂØæÂøúÔºâ
        const isPC = logicalW >= 768;
        let spawnAreaWidth;
        
        if (isPC) {
            spawnAreaWidth = 800;
        } else {
            // „É¢„Éê„Ç§„É´: ‰∏°„Çµ„Ç§„Éâ„ÅÆ„Çæ„Éº„É≥ÂπÖ„ÇíÂèñÂæó
            const zoneW = Math.min(logicalW * 0.28, 180);
            spawnAreaWidth = logicalW - (zoneW * 2);
        }
        
        vacuums.push({
            x: logicalW / 2 + (Math.random() - 0.5) * spawnAreaWidth,
            y: startY,
            vx: (Math.random() - 0.5) * 2.5,
            vy: vyBase + (Math.random() - 0.5) * 1.0,
            radius: 30,
            wobble: Math.random() * Math.PI,
            born: Date.now()
        });
        lastVacuumSpawn = ts;
    }

    // ÊéÉÈô§Ê©ü„ÅÆÁßªÂãïÔºà„Éú„É†„Å®Âêå„ÅòÂãï„ÅçÔºâ
    for (let i = vacuums.length - 1; i >= 0; i--) {
        const vac = vacuums[i];
        vac.x += vac.vx;
        vac.y += vac.vy;
        vac.vx += Math.sin(ts / 500 + vac.wobble) * 0.05;
        
        // Êπß„ÅçÂ†¥ÊâÄ„Ç®„É™„Ç¢„ÅÆÂ¢ÉÁïå„ÇíË®àÁÆó
        const isPC = logicalW >= 768;
        let spawnAreaLeft, spawnAreaRight;
        
        if (isPC) {
            const spawnAreaWidth = 800;
            spawnAreaLeft = (logicalW - spawnAreaWidth) / 2;
            spawnAreaRight = (logicalW + spawnAreaWidth) / 2;
        } else {
            // „É¢„Éê„Ç§„É´: visualW„Çí‰Ωø„Å£„Å¶Ê≠£„Åó„ÅÑÂ¢ÉÁïå„ÇíË®àÁÆó
            const visualZoneW = ZONES.yellow.visualW || ZONES.yellow.w;
            spawnAreaLeft = visualZoneW;
            spawnAreaRight = logicalW - visualZoneW;
        }
        
        // Â£Å„ÅßË∑≥„Å≠Ëøî„ÇãÔºàÊπß„ÅçÂ†¥ÊâÄ„Ç®„É™„Ç¢ÂÜÖ„Å´Âà∂ÈôêÔºâ
        if (vac.x < spawnAreaLeft + vac.radius) { 
            vac.vx = Math.abs(vac.vx); 
            vac.x = spawnAreaLeft + vac.radius; 
        }
        if (vac.x > spawnAreaRight - vac.radius) { 
            vac.vx = -Math.abs(vac.vx); 
            vac.x = spawnAreaRight - vac.radius; 
        }
        if (vac.y < vac.radius) {
            vac.vy = Math.abs(vac.vy);
            vac.y = vac.radius;
        }
        if (vac.y > logicalH - vac.radius) {
            vac.vy = -Math.abs(vac.vy);
            vac.y = logicalH - vac.radius;
        }
    }

    if (Date.now() - lastMatchTime > 3000) {
        combo = 0;
        comboGroup.classList.remove('active');
    }

    if (shakeTime > 0) shakeTime -= 1;
    
    // üß™ÂèñÂæóÂæå„ÅÆËá™ÂãïÂêà‰Ωì„ÉÅ„Çß„ÉÉ„ÇØÔºà„Éâ„É©„ÉÉ„Ç∞‰∏≠„Åß„Å™„ÅÑ„Éú„É†„ÅÆ„ÅøÔºâ
    if (autoMergeLevel > 0 && gameState === 'PLAYING') {
        for (let i = 0; i < bombs.length; i++) {
            const b1 = bombs[i];
            if (b1 === dragging || b1.sizeLevel > autoMergeLevel - 1) continue;
            
            for (let j = i + 1; j < bombs.length; j++) {
                const b2 = bombs[j];
                if (b2 === dragging || b2.sizeLevel > autoMergeLevel - 1) continue;
                if (b1.type !== b2.type || b1.sizeLevel !== b2.sizeLevel) continue;
                
                const dist = Math.hypot(b1.x - b2.x, b1.y - b2.y);
                const levelData = getSizeLevel(b1.sizeLevel);
                const mergeRadius = MERGE_DISTANCE * levelData.scale;
                
                if (dist < mergeRadius) {
                    // Ëá™ÂãïÂêà‰ΩìÔºà„Ç≥„É≥„Éú„ÅØÂàá„Çå„Å™„ÅÑÔºâ
                    const newLevel = b1.sizeLevel + 1;
                    const newLevelData = getSizeLevel(newLevel);
                    
                    bombs.splice(j, 1);
                    
                    b1.sizeLevel = newLevel;
                    b1.born = Date.now();
                    b1.fuseTime = Math.max(4000, 14000 - (score * 0.3)) + newLevelData.fuseBonus;
                    
                    const mergeX = (b1.x + b2.x) / 2;
                    const mergeY = (b1.y + b2.y) / 2;
                    b1.x = mergeX;
                    b1.y = mergeY;
                    
                    createMergeEffect(mergeX, mergeY, b1.color);
                    break; // 1„Éï„É¨„Éº„É†„Å´1Âõû„Å†„Åë
                }
            }
        }
    }
    
    checkForMerges();

    for (let i = bombs.length - 1; i >= 0; i--) {
        const b = bombs[i];
        
        // Áï∞Â∏∏„Å´ÈÄü„ÅÑ„Éú„É†„ÇíÂâäÈô§ÔºàÈÄüÂ∫¶„Åå10‰ª•‰∏äÔºâ
        const speed = Math.sqrt(b.vx * b.vx + b.vy * b.vy);
        if (speed > 10) {
            console.warn('Removing fast bomb:', speed);
            bombs.splice(i, 1);
            continue;
        }
        
        if (b !== dragging) {
            b.x += b.vx;
            b.y += b.vy;
            b.vx += Math.sin(ts / 500 + b.wobble) * 0.05;

            const levelData = getSizeLevel(b.sizeLevel);
            const effectiveRadius = b.r * levelData.scale;

            // Êπß„ÅçÂ†¥ÊâÄ„Ç®„É™„Ç¢„ÅÆÂ¢ÉÁïå„ÇíË®àÁÆóÔºà„Éâ„É©„ÉÉ„Ç∞‰∏≠„Åß„Å™„ÅÑ„Éú„É†„ÅÆ„ÅøÔºâ
            const isPC = logicalW >= 768;
            let spawnAreaLeft, spawnAreaRight;
            
            if (isPC) {
                const spawnAreaWidth = 800;
                spawnAreaLeft = (logicalW - spawnAreaWidth) / 2;
                spawnAreaRight = (logicalW + spawnAreaWidth) / 2;
            } else {
                // „É¢„Éê„Ç§„É´: visualW„Çí‰Ωø„Å£„Å¶Ê≠£„Åó„ÅÑÂ¢ÉÁïå„ÇíË®àÁÆó
                const visualZoneW = ZONES.yellow.visualW || ZONES.yellow.w;
                spawnAreaLeft = visualZoneW;
                spawnAreaRight = logicalW - visualZoneW;
            }

            // Â∑¶Âè≥„ÅÆÂ¢ÉÁïåÔºàÊπß„ÅçÂ†¥ÊâÄ„Ç®„É™„Ç¢ÂÜÖ„Å´Âà∂ÈôêÔºâ
            if (b.x < spawnAreaLeft + effectiveRadius) { 
                b.vx = Math.abs(b.vx) * 0.8; // ÈÄüÂ∫¶„ÇíÂ∞ë„ÅóÊ∏õË°∞
                b.x = spawnAreaLeft + effectiveRadius; 
            }
            if (b.x > spawnAreaRight - effectiveRadius) { 
                b.vx = -Math.abs(b.vx) * 0.8; // ÈÄüÂ∫¶„ÇíÂ∞ë„ÅóÊ∏õË°∞
                b.x = spawnAreaRight - effectiveRadius; 
            }
            
            // ‰∏ä‰∏ã„ÅÆÂ¢ÉÁïå
            if (b.y < effectiveRadius) {
                b.vy = Math.abs(b.vy) * 0.8; // ÈÄüÂ∫¶„ÇíÂ∞ë„ÅóÊ∏õË°∞
                b.y = effectiveRadius;
            }
            if (b.y > logicalH - effectiveRadius) {
                b.vy = -Math.abs(b.vy) * 0.8; // ÈÄüÂ∫¶„ÇíÂ∞ë„ÅóÊ∏õË°∞
                b.y = logicalH - effectiveRadius;
            }
        }
        // „Éâ„É©„ÉÉ„Ç∞‰∏≠„ÅØÂà∂Èôê„Å™„ÅóÔºàÁîªÈù¢ÂÖ®‰Ωì„ÇíÁßªÂãïÂèØËÉΩÔºâ
        
        if (gameState === 'PLAYING' && Date.now() - b.born > b.fuseTime) {
            finalCounts.yellow = sortedBombs.yellow.length;
            finalCounts.indigo = sortedBombs.indigo.length;
            createBigExplosion(b.x, b.y);
            bombs.splice(i, 1);
            doGameOver("ÂéüÂõ†ÔºöÁ™ÅÁÑ∂„ÅÆË£èÂàá„Çä");
        }
    }
}

// ===== Drawing =====
function drawBomb(b, isStatic = false) {
    const age = Date.now() - b.born;
    const isUrgent = !isStatic && age > b.fuseTime * 0.75;
    const pulse = (isUrgent && gameState === 'PLAYING') ? Math.sin(Date.now() / 40) * 4 : 0;
    const isHovered = !isStatic && !dragging && gameState === 'PLAYING' && Math.hypot(mousePos.x - b.x, mousePos.y - b.y) < b.r + HIT_SLOP;

    const levelData = getSizeLevel(b.sizeLevel);
    const scale = levelData.scale;

    ctx.save();
    ctx.translate(b.x, b.y);

    if (imgReady) {
        const currentDrawSize = (DRAW_SIZE * scale) + pulse * 2;
        const sx = b.spriteIndex * TILE_SIZE;
        const sy = 0;

        if (b.sizeLevel > 0 && gameState === 'PLAYING') {
            ctx.shadowColor = b.color;
            ctx.shadowBlur = 15 + Math.sin(Date.now() / 200) * 5;
        }

        ctx.drawImage(
            bombSprite, 
            sx, sy, TILE_SIZE, TILE_SIZE,  
            -currentDrawSize/2, -currentDrawSize/2, currentDrawSize, currentDrawSize 
        );
        
        ctx.shadowBlur = 0;
        
        if (isHovered && !('ontouchstart' in window)) {
            ctx.strokeStyle = "#fff";
            ctx.lineWidth = 2;
            ctx.strokeRect(-currentDrawSize/2, -currentDrawSize/2, currentDrawSize, currentDrawSize);
        }
    } else {
        ctx.beginPath();
        ctx.arc(0, 0, (b.r * scale) + pulse, 0, Math.PI*2);
        ctx.fillStyle = b.color;
        ctx.fill();
    }
    ctx.restore();
}

function draw() {
    const logicalW = canvas.width / (window.devicePixelRatio || 1);
    const logicalH = canvas.height / (window.devicePixelRatio || 1);

    ctx.save();
    if (shakeTime > 0) ctx.translate((Math.random()-0.5)*shakeTime, (Math.random()-0.5)*shakeTime);
    ctx.clearRect(0, 0, logicalW, logicalH);

    Object.entries(ZONES).forEach(([key, z]) => {
        // ÊèèÁîªÁî®„ÅÆÂ∫ßÊ®ôÔºà„É¢„Éê„Ç§„É´„Åß„ÅØvisual„Éó„É≠„Éë„ÉÜ„Ç£„Çí‰ΩøÁî®Ôºâ
        const drawX = z.visualX !== undefined ? z.visualX : z.x;
        const drawY = z.visualY !== undefined ? z.visualY : z.y;
        const drawW = z.visualW !== undefined ? z.visualW : z.w;
        const drawH = z.visualH !== undefined ? z.visualH : z.h;
        
        const isYellow = key === 'yellow';
        const gradient = ctx.createLinearGradient(isYellow ? drawX : drawX + drawW, drawY, isYellow ? drawX + drawW : drawX, drawY);
        gradient.addColorStop(0, z.glow);
        gradient.addColorStop(1, 'transparent');
        ctx.fillStyle = gradient;
        ctx.fillRect(drawX, drawY, drawW, drawH);
        ctx.strokeStyle = z.color;
        ctx.lineWidth = 3;
        ctx.beginPath();
        const lineX = isYellow ? drawX + drawW : drawX;
        ctx.moveTo(lineX, drawY); ctx.lineTo(lineX, drawY + drawH);
        ctx.stroke();

        ctx.setLineDash([8, 4]);
        ctx.lineWidth = 1; ctx.globalAlpha = 0.4;
        ctx.beginPath(); ctx.moveTo(drawX, drawY); ctx.lineTo(drawX + drawW, drawY); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(drawX, drawY + drawH); ctx.lineTo(drawX + drawW, drawY + drawH); ctx.stroke();
        ctx.setLineDash([]); ctx.globalAlpha = 1.0;
    });

    sortedBombs.yellow.forEach(b => drawBomb(b, true));
    sortedBombs.indigo.forEach(b => drawBomb(b, true));
    bombs.forEach(b => drawBomb(b, false));

    // üß™„Éì„Éº„Ç´„Éº„ÅÆÊèèÁîª
    beakers.forEach(beaker => {
        ctx.save();
        ctx.translate(beaker.x, beaker.y);
        
        // „Éì„Éº„Ç´„Éº„ÅÆ„Ç¢„Ç§„Ç≥„É≥
        ctx.fillStyle = "#ff66ff";
        ctx.strokeStyle = "#fff";
        ctx.lineWidth = 3;
        
        // Êú¨‰Ωì
        ctx.beginPath();
        ctx.arc(0, 0, beaker.radius, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();
        
        // üß™„Éû„Éº„ÇØ
        ctx.fillStyle = "#fff";
        ctx.font = "bold 28px Arial";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText("üß™", 0, 0);
        
        // „É¨„Éô„É´Ë°®Á§∫
        ctx.font = "bold 14px Inter";
        ctx.fillStyle = "#fff";
        ctx.strokeStyle = "#000";
        ctx.lineWidth = 3;
        ctx.strokeText(`Lv${beaker.level}`, 0, beaker.radius + 18);
        ctx.fillText(`Lv${beaker.level}`, 0, beaker.radius + 18);
        
        // „Éõ„Éê„Éº„Ç®„Éï„Çß„ÇØ„Éà
        const dist = Math.hypot(mousePos.x - beaker.x, mousePos.y - beaker.y);
        if (dist < beaker.radius + 20) {
            ctx.strokeStyle = "#ffff00";
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.arc(0, 0, beaker.radius + 5, 0, Math.PI * 2);
            ctx.stroke();
        }
        
        ctx.restore();
    });

    // ÊéÉÈô§Ê©ü„ÅÆÊèèÁîª
    vacuums.forEach(vac => {
        ctx.save();
        ctx.translate(vac.x, vac.y);
        
        // ÊéÉÈô§Ê©ü„ÅÆ„Ç¢„Ç§„Ç≥„É≥ÔºàÁ∞°ÊòìÁâàÔºâ
        ctx.fillStyle = "#44ff44";
        ctx.strokeStyle = "#fff";
        ctx.lineWidth = 3;
        
        // Êú¨‰Ωì
        ctx.beginPath();
        ctx.arc(0, 0, vac.radius, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();
        
        // ÊéÉÈô§Ê©ü„Éû„Éº„ÇØ
        ctx.fillStyle = "#fff";
        ctx.font = "bold 28px Arial";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText("üßπ", 0, 0);
        
        // „Éõ„Éê„Éº„Ç®„Éï„Çß„ÇØ„Éà
        const dist = Math.hypot(mousePos.x - vac.x, mousePos.y - vac.y);
        if (dist < vac.radius + 20) {
            ctx.strokeStyle = "#ffff00";
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.arc(0, 0, vac.radius + 5, 0, Math.PI * 2);
            ctx.stroke();
        }
        
        ctx.restore();
    });

    particles.forEach((p, i) => {
        ctx.globalAlpha = p.life;
        ctx.fillStyle = p.color;
        ctx.beginPath(); ctx.arc(p.x, p.y, p.r, 0, Math.PI*2); ctx.fill();
        p.x += p.vx; p.y += p.vy; p.life -= p.decay;
        if(p.life <= 0) particles.splice(i, 1);
    });

    floatingTexts.forEach((t, i) => {
        ctx.globalAlpha = t.life;
        ctx.fillStyle = t.color;
        ctx.font = `900 ${t.size}px 'Inter'`;
        ctx.textAlign = "center";
        ctx.fillText(t.text, t.x, t.y);
        t.y += t.vy; t.life -= 0.025;
        if(t.life <= 0) floatingTexts.splice(i, 1);
    });
    
    mergeEffects.forEach((e, i) => {
        ctx.globalAlpha = e.life * 0.6;
        ctx.strokeStyle = e.color;
        ctx.lineWidth = 4;
        ctx.beginPath();
        ctx.arc(e.x, e.y, e.radius, 0, Math.PI * 2);
        ctx.stroke();
        
        e.radius += (e.maxRadius - e.radius) * 0.15;
        e.life -= 0.04;
        if(e.life <= 0) mergeEffects.splice(i, 1);
    });
    
    ctx.restore();
    requestAnimationFrame((ts) => { update(ts); draw(); });
}

const onMove = e => {
    const p = getPos(e);
    lastMousePos.x = mousePos.x;
    lastMousePos.y = mousePos.y;
    mousePos.x = p.x; 
    mousePos.y = p.y;
    
    if(!dragging || gameState !== 'PLAYING') return;
    
    const levelData = getSizeLevel(dragging.sizeLevel);
    const dragWeight = levelData.dragWeight;
    
    const targetX = p.x - touchOffset.x;
    const targetY = p.y - touchOffset.y;
    
    dragging.x += (targetX - dragging.x) * dragWeight;
    dragging.y += (targetY - dragging.y) * dragWeight;
    
    if(e.cancelable) e.preventDefault();
};

let lastMergeCheck = 0;
const MERGE_CHECK_INTERVAL = 50;

function checkForMerges() {
    const now = Date.now();
    if (!dragging || now - lastMergeCheck < MERGE_CHECK_INTERVAL) return;
    lastMergeCheck = now;
    
    const mergeCheck = checkMerge(dragging);
    if (mergeCheck) {
        const mergedBomb = mergeBombs(dragging, mergeCheck.target, mergeCheck.index);
        dragging = mergedBomb;
        touchOffset.x = mousePos.x - mergedBomb.x;
        touchOffset.y = mousePos.y - mergedBomb.y;
        lastMergeCheck = now + MERGE_COOLDOWN;
    }
}

const onEnd = () => {
    if (!dragging || gameState !== 'PLAYING') return;
    checkZoneEntry(dragging);
    dragging = null;
};

function getPos(e) {
    const r = canvas.getBoundingClientRect();
    const cx = e.touches ? e.touches[0].clientX : e.clientX;
    const cy = e.touches ? e.touches[0].clientY : e.clientY;
    
    return {
        x: (cx - r.left),
        y: (cy - r.top)
    };
}

canvas.addEventListener("mousedown", onStart);
window.addEventListener("mousemove", onMove);
window.addEventListener("mouseup", onEnd);
canvas.addEventListener("touchstart", onStart, {passive:false});
window.addEventListener("touchmove", onMove, {passive:false});
window.addEventListener("touchend", onEnd);

// ===== Flow =====
function startGame() {
    score = 0; combo = 0; maxCombo = 0;
    bombs = [];
    sortedBombs = { yellow: [], indigo: [] };
    finalCounts = { yellow: 0, indigo: 0 };
    particles = []; floatingTexts = []; mergeEffects = [];
    vacuums = [];
    beakers = [];
    autoMergeLevel = 0;
    beakerSchedule = [10000, 20000, 30000, 40000, 50000];
    currentBeakerIndex = 0;
    lastSpawn = performance.now();
    lastVacuumSpawn = performance.now();
    spawnInterval = 1200;
    scoreEl.innerText = "0";
    comboEl.innerText = "0";
    comboGroup.classList.remove('active');
    updateRankUI();
    gameState = 'PLAYING';
    overlay.classList.add('hidden');
    resultBox.classList.add('hidden');
    statusTitle.innerHTML = "ELECTRO<br>RECOVERY";
    statusTitle.style.color = "white";
    statusMsg.innerHTML = "„Éâ„É©„ÉÉ„Ç∞„Åó„Å¶Ëâ≤„Çí‰ªïÂàÜ„Åë„Çç„ÄÇ<br>„Éü„Çπ„ÅØË®±„Åï„Çå„Å™„ÅÑ„ÄÇ";
    resize();
}

function doGameOver(reason) {
    gameState = 'GAMEOVER';
    statusTitle.innerText = "SYSTEM FAILED";
    statusTitle.style.color = "var(--neon-red)";
    
    // „Éè„Ç§„Çπ„Ç≥„Ç¢Êõ¥Êñ∞
    if (score > highScore) highScore = score;
    
    // „Éá„Éê„Ç§„ÇπÂà§ÂÆö
    const logicalW = canvas.width / (window.devicePixelRatio || 1);
    const isPC = logicalW >= 768;
    const deviceName = isPC ? "PC" : "MOBILE";
    
    const rank = getRank(score);
    finalRankBox.innerText = rank.name;
    finalRankBox.style.color = rank.color;
    document.getElementById("res-highscore").innerText = highScore;
    document.getElementById("res-maxcombo").innerText = maxCombo;
    document.getElementById("res-yellow").innerText = finalCounts.yellow;
    document.getElementById("res-indigo").innerText = finalCounts.indigo;
    document.getElementById("res-total").innerText = finalCounts.yellow + finalCounts.indigo;
    document.getElementById("res-device").innerText = deviceName;
    
    resultBox.classList.remove('hidden');
    statusMsg.innerHTML = `<span style="color: #fff; font-weight: bold;">${reason}</span><br>FINAL SCORE: ${score}`;
    
    actionBtn.innerText = "REBOOT";
    overlay.classList.remove('hidden');
}

draw();
</script>
</body>
</html>