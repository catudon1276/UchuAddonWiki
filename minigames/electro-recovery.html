<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>ELECTRO RECOVERY</title>
    <style>
        :root {
            --yellow-glow: #ffcc00;
            --indigo-glow: #3b5998;
            --accent-yellow: #ffcc00;
            --neon-red: #ff0044;
        }
        * {
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }
        html {
            height: 100%;
            overflow: hidden;
        }
        
        body {
            background: #050508;
            color: white;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            height: 100%;
            min-height: 100vh;
            min-height: -webkit-fill-available;
            margin: 0;
            padding: 0;
            font-family: 'Inter', 'Segoe UI', system-ui, sans-serif;
            overflow: hidden;
            touch-action: none;
            position: fixed;
            width: 100%;
        }

        .header-ui {
            width: 100%;
            min-height: 60px;
            max-height: 80px;
            height: 12vh;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 15px;
            background: linear-gradient(to bottom, rgba(255,255,255,0.03) 0%, transparent 100%);
            border-bottom: 1px solid rgba(255,255,255,0.08);
            z-index: 10;
            flex-shrink: 0;
            padding: 5px 10px;
        }

        .stat-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            min-width: 60px;
            flex: 0 1 auto;
        }

        .score-label { 
            font-size: 8px; 
            color: rgba(255,255,255,0.4); 
            text-transform: uppercase; 
            letter-spacing: 1px;
            margin-bottom: 1px;
            white-space: nowrap;
        }
        .score-val { 
            font-size: clamp(18px, 5vw, 28px);
            font-weight: 900; 
            font-variant-numeric: tabular-nums; 
        }

        #rank-display {
            font-size: clamp(16px, 4.5vw, 24px);
            font-weight: 900;
            font-style: italic;
        }
        
        #combo-group {
            transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            transform: scale(0);
            opacity: 0;
        }
        #combo-group.active {
            transform: scale(1);
            opacity: 1;
        }
        
        .rainbow-text {
            animation: rainbow 2s linear infinite;
        }
        @keyframes rainbow {
            0% { color: #ff0000; }
            20% { color: #ffff00; }
            40% { color: #00ff00; }
            60% { color: #00ffff; }
            80% { color: #0000ff; }
            100% { color: #ff00ff; }
        }

        #game-container {
            position: relative;
            width: 100%;
            flex: 1; 
            min-height: 0;
            background: #000;
            overflow: hidden;
            display: flex;
        }

        canvas {
            background: radial-gradient(circle at center, #0e0e12 0%, #000 100%);
            width: 100%;
            height: 100%;
            display: block;
            touch-action: none;
        }
        
        #overlay-screen {
            position: absolute;
            inset: 0;
            background: rgba(0,0,0,0.92);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
            transition: opacity 0.4s;
            backdrop-filter: blur(15px);
            padding: 20px;
        }
        h1 { 
            font-size: clamp(32px, 10vw, 48px);
            font-weight: 900; 
            margin: 0; 
            letter-spacing: -1px; 
            text-align: center; 
            line-height: 1.1;
            padding: 0 10px;
        }
        
        .rank-large {
            font-size: clamp(48px, 15vw, 80px);
            font-weight: 900;
            margin: 10px 0;
        }

        .result-stats {
            display: flex;
            gap: 10px;
            margin: 10px 0;
            padding: 10px 15px;
            background: rgba(255,255,255,0.05);
            border-radius: 8px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .res-item {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .res-label {
            font-size: 9px;
            color: rgba(255,255,255,0.4);
            text-transform: uppercase;
        }

        .res-val {
            font-size: clamp(16px, 4vw, 20px);
            font-weight: 900;
        }

        .btn {
            padding: 12px 30px;
            font-size: clamp(14px, 3.5vw, 18px);
            background: #fff;
            color: #000;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 900;
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-top: 10px;
        }
        .hidden { opacity: 0 !important; pointer-events: none !important; }

        /* Tablet/Desktop scale up */
        @media (min-width: 768px) {
            .header-ui { 
                height: 15vh;
                max-height: 100px; 
                gap: 60px; 
            }
            .score-val { font-size: 48px; }
            #rank-display { font-size: 32px; }
            h1 { font-size: 72px; }
            .rank-large { font-size: 120px; }
            .res-val { font-size: 32px; }
            .stat-group { min-width: 80px; }
        }
        
        /* Small mobile optimization */
        @media (max-width: 380px) {
            .header-ui {
                gap: 8px;
                padding: 5px;
            }
            .stat-group {
                min-width: 50px;
            }
            .score-label {
                font-size: 7px;
                letter-spacing: 0.5px;
            }
        }
    </style>
</head>
<body>

    <header class="header-ui">
        <div class="stat-group">
            <div class="score-label">SCORE</div>
            <div id="score" class="score-val">0</div>
        </div>
        <div class="stat-group">
            <div class="score-label">RANK</div>
            <div id="rank-display">C</div>
        </div>
        <div id="combo-group" class="stat-group">
            <div class="score-label">COMBO</div>
            <div id="combo" class="score-val" style="color: var(--accent-yellow);">0</div>
        </div>
    </header>

    <div id="game-container">
        <div id="overlay-screen">
            <h1 id="status-title">ELECTRO<br>RECOVERY</h1>
            
            <div id="result-box" class="hidden" style="display: flex; flex-direction: column; align-items: center; width: 100%;">
                <div id="final-rank-box" class="rank-large">C</div>
                <div class="result-stats">
                    <div class="res-item">
                        <div class="res-label">HIJIKI</div>
                        <div id="res-yellow" class="res-val" style="color: var(--yellow-glow);">0</div>
                    </div>
                    <div class="res-item">
                        <div class="res-label">LOZ</div>
                        <div id="res-indigo" class="res-val" style="color: #5c7cfa;">0</div>
                    </div>
                    <div class="res-item">
                        <div class="res-label">TOTAL</div>
                        <div id="res-total" class="res-val">0</div>
                    </div>
                </div>
            </div>

            <p id="status-msg" style="color: #ccc; margin: 10px 0 20px; text-align: center; max-width: 90%; line-height: 1.5; font-size: clamp(12px, 3vw, 14px); padding: 0 15px;">
                ドラッグして色を仕分けろ。<br>ミスは許されない。
            </p>
            <button class="btn" onclick="startGame()" id="action-btn">INITIALIZE</button>
        </div>
        <canvas id="game"></canvas>
    </div>

<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
const scoreEl = document.getElementById("score");
const comboEl = document.getElementById("combo");
const rankEl = document.getElementById("rank-display");
const comboGroup = document.getElementById("combo-group");
const overlay = document.getElementById("overlay-screen");
const statusTitle = document.getElementById("status-title");
const statusMsg = document.getElementById("status-msg");
const finalRankBox = document.getElementById("final-rank-box");
const resultBox = document.getElementById("result-box");
const actionBtn = document.getElementById("action-btn");

// ===== Asset Loading =====
const bombSprite = new Image();
bombSprite.src = "../resource/HjkBom.png"; 

let imgReady = false;
bombSprite.onload = () => { imgReady = true; };

// ===== Constants & Config =====
let ZONES = {};
const GRID = { padding: 35 }; 
const BOMB_RADIUS = 22;
const TILE_SIZE = 64; 
const DRAW_SIZE = 54; 
const HIT_SLOP = 50; 
const VISUAL_CAPACITY = 100;
const MERGE_DISTANCE = 100;
const SIZE_LEVELS = [
    { scale: 1.0, fuseBonus: 0, scoreMultiplier: 1, name: "Normal", dragWeight: 1.0 },
    { scale: 1.4, fuseBonus: 2000, scoreMultiplier: 5, name: "Big", dragWeight: 1.0 },
    { scale: 1.8, fuseBonus: 3000, scoreMultiplier: 12, name: "Huge", dragWeight: 0.7 },
    { scale: 2.2, fuseBonus: 4000, scoreMultiplier: 25, name: "Mega", dragWeight: 0.4 }
];
const MERGE_COOLDOWN = 300; 

// ===== Game State =====
let gameState = 'START'; 
let bombs = [];
let sortedBombs = { yellow: [], indigo: [] };
let finalCounts = { yellow: 0, indigo: 0 };
let particles = [];
let floatingTexts = [];
let mergeEffects = [];
let dragging = null;
let mousePos = { x: 0, y: 0 };
let lastMousePos = { x: 0, y: 0 };
let touchOffset = { x: 0, y: 0 };
let score = 0;
let combo = 0;
let lastMatchTime = 0;
let lastSpawn = 0;
let spawnInterval = 1800;
let shakeTime = 0;

// ===== Rank System =====
function getRank(s) {
    if (s < 1000) return { name: "C", color: "#aaa" };
    if (s < 3000) return { name: "B", color: "#8f8" };
    if (s < 6000) return { name: "A", color: "#4af" };
    if (s < 12000) return { name: "S", color: "#f5f" };
    if (s < 20000) return { name: "SS", color: "#f22" };
    if (s < 30000) return { name: "SSS", color: "#ff0" };
    if (s < 45000) return { name: "SSS+", color: "#fff" };
    if (s < 65000) return { name: "X", color: "#ff8c00" }; 
    if (s < 90000) return { name: "XX", color: "#00ffcc" };
    if (s < 120000) return { name: "XXX", color: "#ff00ff" };
    const uNum = Math.floor((s - 120000) / 40000) + 1;
    return { name: `U${uNum}`, color: "#fff", special: true };
}

function updateRankUI() {
    const r = getRank(score);
    rankEl.innerText = r.name;
    if (r.special) {
        rankEl.style.background = "linear-gradient(45deg, #ff0, #f0f, #0ff)";
        rankEl.style.webkitTextFillColor = "transparent";
        rankEl.style.webkitBackgroundClip = "text";
        rankEl.classList.add('rainbow-text');
    } else {
        rankEl.style.background = "none";
        rankEl.style.webkitTextFillColor = r.color;
        rankEl.classList.remove('rainbow-text');
    }
}

// ===== Setup =====
function resize() {
    const container = document.getElementById("game-container");
    const dpr = window.devicePixelRatio || 1;
    const rect = container.getBoundingClientRect();
    
    canvas.width = rect.width * dpr;
    canvas.height = rect.height * dpr;
    ctx.scale(dpr, dpr);
    
    // UI layout scaling for mobile
    const logicalWidth = rect.width;
    const logicalHeight = rect.height;

    // Adaptive zone width based on screen size
    const zoneW = Math.min(logicalWidth * 0.28, 180);
    const marginY = Math.max(20, logicalHeight * 0.08);
    const zoneH = logicalHeight - (marginY * 2); 
    
    ZONES = {
        yellow: { x: 0, y: marginY, w: zoneW, h: zoneH, color: '#ffcc00', glow: 'rgba(255, 204, 0, 0.15)' },
        indigo: { x: logicalWidth - zoneW, y: marginY, w: zoneW, h: zoneH, color: '#3b5998', glow: 'rgba(59, 89, 152, 0.15)' }
    };

    // Update grid padding for mobile
    GRID.padding = Math.max(25, Math.min(35, zoneW / 4));
}

// Mobile viewport height fix
function setVH() {
    const vh = window.innerHeight * 0.01;
    document.documentElement.style.setProperty('--vh', `${vh}px`);
}

window.addEventListener('resize', () => {
    setVH();
    resize();
});
window.addEventListener('orientationchange', () => {
    setTimeout(() => {
        setVH();
        resize();
    }, 300);
});

setVH();
resize();

// ===== FX Utils =====
function createText(x, y, text, color, size = 24) {
    floatingTexts.push({ x, y, text, color, life: 1.0, vy: -1.5, size });
}

function createParticles(x, y, color, count = 10, speed = 8) {
    for (let i = 0; i < count; i++) {
        const ang = Math.random() * Math.PI * 2;
        const s = Math.random() * speed;
        particles.push({
            x, y,
            vx: Math.cos(ang) * s,
            vy: Math.sin(ang) * s,
            r: Math.random() * 3 + 1,
            color,
            life: 1.0,
            decay: 0.03 + Math.random() * 0.03
        });
    }
}

function applyShake(intensity = 10) {
    shakeTime = intensity;
}

function createBigExplosion(x, y) {
    applyShake(15);
    for (let i = 0; i < 30; i++) {
        const ang = Math.random() * Math.PI * 2;
        const s = Math.random() * 20;
        particles.push({
            x, y,
            vx: Math.cos(ang) * s,
            vy: Math.sin(ang) * s,
            r: Math.random() * 6 + 1,
            color: Math.random() > 0.3 ? "#ff4400" : (Math.random() > 0.5 ? "#ffcc00" : "#fff"),
            life: 1.0,
            decay: 0.02
        });
    }
}

function createMergeEffect(x, y, color) {
    mergeEffects.push({
        x, y,
        color,
        radius: 10,
        maxRadius: 60,
        life: 1.0
    });
    applyShake(8);
    createParticles(x, y, color, 20, 12);
}

async function triggerChainExplosionSequence(wrongZoneType, wrongBomb, reason) {
    if (gameState === 'EXPLODING' || gameState === 'GAMEOVER') return;
    gameState = 'EXPLODING';
    dragging = null; 

    finalCounts.yellow = sortedBombs.yellow.length;
    finalCounts.indigo = sortedBombs.indigo.length;

    sortedBombs[wrongZoneType].push(wrongBomb);
    const bombIdx = bombs.indexOf(wrongBomb);
    if (bombIdx > -1) bombs.splice(bombIdx, 1);

    const targetList = sortedBombs[wrongZoneType];
    ZONES[wrongZoneType].glow = 'rgba(255, 0, 40, 0.7)';

    const explosionLimit = Math.min(targetList.length, VISUAL_CAPACITY);
    for (let i = 0; i < explosionLimit; i++) {
        const b = targetList.pop();
        if (b) createBigExplosion(b.x, b.y);
        await new Promise(r => setTimeout(r, 40));
    }
    sortedBombs[wrongZoneType] = [];

    for (let i = bombs.length - 1; i >= 0; i--) {
        const b = bombs[i];
        createBigExplosion(b.x, b.y);
        bombs.splice(i, 1);
        if (i % 3 === 0) await new Promise(r => setTimeout(r, 10));
    }

    setTimeout(() => doGameOver(reason), 800);
}

// ===== Logic =====
function spawnBomb() {
    const logicalW = canvas.width / (window.devicePixelRatio || 1);
    const logicalH = canvas.height / (window.devicePixelRatio || 1);

    const isIndigo = Math.random() < 0.5;
    const type = isIndigo ? "indigo" : "yellow";
    const spriteIndex = isIndigo ? 1 : 0;
    
    const topSpawnChance = score < 1000 ? 0.3 : Math.min(0.6, (score - 1000) / 15000);
    const spawnFromTop = Math.random() < topSpawnChance;
    
    const startY = spawnFromTop ? -40 : logicalH + 40;
    const baseSpeed = 2.5 + score/8000;
    const vyBase = spawnFromTop ? baseSpeed : -baseSpeed;

    bombs.push({
        x: logicalW / 2 + (Math.random() - 0.5) * (logicalW * 0.3),
        y: startY,
        vx: (Math.random() - 0.5) * (2.5 + score/10000),
        vy: vyBase + (Math.random() - 0.5) * 1.2,
        r: BOMB_RADIUS,
        type,
        spriteIndex, 
        born: Date.now(),
        fuseTime: Math.max(4000, 12000 - (score * 0.3)), 
        wobble: Math.random() * Math.PI,
        color: type === 'yellow' ? '#ffcc00' : '#3b5998',
        sizeLevel: 0
    });
}

function getSortedPosition(type, index) {
    const zone = ZONES[type];
    const cols = Math.floor((zone.w - 20) / GRID.padding);
    const visualIndex = index % VISUAL_CAPACITY;
    
    const col = visualIndex % Math.max(1, cols);
    const row = Math.floor(visualIndex / Math.max(1, cols));
    
    const startX = type === 'yellow' ? 25 : zone.x + 25;
    const startY = zone.y + 40;
    return {
        x: startX + (col * GRID.padding),
        y: startY + (row * GRID.padding)
    };
}

function checkMerge(draggedBomb) {
    if (!draggedBomb || draggedBomb.sizeLevel >= SIZE_LEVELS.length - 1) return null;
    
    for (let i = bombs.length - 1; i >= 0; i--) {
        const b = bombs[i];
        if (b === draggedBomb) continue;
        
        const dist = Math.hypot(b.x - draggedBomb.x, b.y - draggedBomb.y);
        const levelData = SIZE_LEVELS[b.sizeLevel];
        const mergeRadius = MERGE_DISTANCE * levelData.scale;
        
        if (dist < mergeRadius && 
            b.type === draggedBomb.type && 
            b.sizeLevel === draggedBomb.sizeLevel) {
            return { target: b, index: i };
        }
    }
    return null;
}

function mergeBombs(b1, b2, b2Index) {
    const newLevel = Math.min(b1.sizeLevel + 1, SIZE_LEVELS.length - 1);
    const levelData = SIZE_LEVELS[newLevel];
    
    bombs.splice(b2Index, 1);
    
    b1.sizeLevel = newLevel;
    b1.born = Date.now();
    b1.fuseTime = Math.max(3000, 12000 - (score * 0.4)) + levelData.fuseBonus;
    
    const mergeX = (b1.x + b2.x) / 2;
    const mergeY = (b1.y + b2.y) / 2;
    b1.x = mergeX;
    b1.y = mergeY;
    
    createMergeEffect(mergeX, mergeY, b1.color);
    
    return b1;
}

function checkZoneEntry(b) {
    const withinXYellow = b.x < ZONES.yellow.x + ZONES.yellow.w;
    const withinXIndigo = b.x > ZONES.indigo.x;
    const withinY = b.y > ZONES.yellow.y && b.y < ZONES.yellow.y + ZONES.yellow.h;
    
    if (withinY && (withinXYellow || withinXIndigo)) {
        const zoneType = withinXYellow ? 'yellow' : 'indigo';
        
        if (b.type === zoneType) {
            const index = sortedBombs[zoneType].length;
            const targetPos = getSortedPosition(zoneType, index);
            b.x = targetPos.x; b.y = targetPos.y;

            sortedBombs[zoneType].push(b);
            const bombIdx = bombs.indexOf(b);
            if (bombIdx > -1) bombs.splice(bombIdx, 1);

            const levelData = SIZE_LEVELS[b.sizeLevel];
            
            if (b.sizeLevel > 0) {
                combo = 0;
                comboGroup.classList.remove('active');
                const megaPoints = 100 * levelData.scoreMultiplier;
                score += megaPoints;
                createText(b.x, b.y, `+${megaPoints}`, "#ffff00", 32);
                createText(b.x, b.y - 40, `${levelData.name.toUpperCase()} BONUS!`, "#fff", 20);
                applyShake(12);
            } else {
                combo++;
                lastMatchTime = Date.now();
                const points = Math.floor(10 * (1 + combo * 0.1));
                score += points;
                if (combo > 1) comboGroup.classList.add('active');
                createText(b.x, b.y, `+${points}`, ZONES[zoneType].color);
            }
            
            const oldRank = getRank(score - (b.sizeLevel > 0 ? 100 * levelData.scoreMultiplier : Math.floor(10 * (1 + combo * 0.1)))).name;
            scoreEl.innerText = score;
            comboEl.innerText = combo;
            updateRankUI();

            if (oldRank !== getRank(score).name) {
                const logicalW = canvas.width / (window.devicePixelRatio || 1);
                const logicalH = canvas.height / (window.devicePixelRatio || 1);
                createText(logicalW/2, logicalH/2, "RANK UP!", "#fff", 40);
                applyShake(10);
            }

            createParticles(b.x, b.y, ZONES[zoneType].color, b.sizeLevel > 0 ? 15 : 8);
            return true;
        } else {
            triggerChainExplosionSequence(zoneType, b, "原因：扱い方を間違えた末路");
            return false;
        }
    }
    return false;
}

function update(ts) {
    if (gameState !== 'PLAYING' && gameState !== 'EXPLODING') return;

    const logicalW = canvas.width / (window.devicePixelRatio || 1);
    const logicalH = canvas.height / (window.devicePixelRatio || 1);

    if (gameState === 'PLAYING' && ts - lastSpawn > spawnInterval) {
        spawnBomb();
        lastSpawn = ts;
        spawnInterval = Math.max(200, 700 - (score * 0.08));
    }

    if (Date.now() - lastMatchTime > 3000) {
        combo = 0;
        comboGroup.classList.remove('active');
    }

    if (shakeTime > 0) shakeTime -= 1;
    
    checkForMerges();

    for (let i = bombs.length - 1; i >= 0; i--) {
        const b = bombs[i];
        if (b !== dragging) {
            b.x += b.vx;
            b.y += b.vy;
            b.vx += Math.sin(ts / 500 + b.wobble) * 0.05;

            const levelData = SIZE_LEVELS[b.sizeLevel];
            const effectiveRadius = b.r * levelData.scale;

            if (b.x < effectiveRadius) { 
                b.vx = Math.abs(b.vx); 
                b.x = effectiveRadius; 
            }
            if (b.x > logicalW - effectiveRadius) { 
                b.vx = -Math.abs(b.vx); 
                b.x = logicalW - effectiveRadius; 
            }
            
            if (b.y < effectiveRadius) {
                b.vy = Math.abs(b.vy);
                b.y = effectiveRadius;
            }
            if (b.y > logicalH - effectiveRadius) {
                b.vy = -Math.abs(b.vy);
                b.y = logicalH - effectiveRadius;
            }
        }
        if (gameState === 'PLAYING' && Date.now() - b.born > b.fuseTime) {
            finalCounts.yellow = sortedBombs.yellow.length;
            finalCounts.indigo = sortedBombs.indigo.length;
            createBigExplosion(b.x, b.y);
            bombs.splice(i, 1);
            doGameOver("原因：突然の裏切り");
        }
    }
}

// ===== Drawing =====
function drawBomb(b, isStatic = false) {
    const age = Date.now() - b.born;
    const isUrgent = !isStatic && age > b.fuseTime * 0.75;
    const pulse = (isUrgent && gameState === 'PLAYING') ? Math.sin(Date.now() / 40) * 4 : 0;
    const isHovered = !isStatic && !dragging && gameState === 'PLAYING' && Math.hypot(mousePos.x - b.x, mousePos.y - b.y) < b.r + HIT_SLOP;

    const levelData = SIZE_LEVELS[b.sizeLevel];
    const scale = levelData.scale;

    ctx.save();
    ctx.translate(b.x, b.y);

    if (imgReady) {
        const currentDrawSize = (DRAW_SIZE * scale) + pulse * 2;
        const sx = b.spriteIndex * TILE_SIZE;
        const sy = 0;

        if (b.sizeLevel > 0 && gameState === 'PLAYING') {
            ctx.shadowColor = b.color;
            ctx.shadowBlur = 15 + Math.sin(Date.now() / 200) * 5;
        }

        ctx.drawImage(
            bombSprite, 
            sx, sy, TILE_SIZE, TILE_SIZE,  
            -currentDrawSize/2, -currentDrawSize/2, currentDrawSize, currentDrawSize 
        );
        
        ctx.shadowBlur = 0;
        
        if (isHovered && !('ontouchstart' in window)) {
            ctx.strokeStyle = "#fff";
            ctx.lineWidth = 2;
            ctx.strokeRect(-currentDrawSize/2, -currentDrawSize/2, currentDrawSize, currentDrawSize);
        }
        
        if (b.sizeLevel > 0) {
            ctx.font = `900 ${12 * scale}px 'Inter'`;
            ctx.fillStyle = "#fff";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.strokeStyle = "#000";
            ctx.lineWidth = 3;
            ctx.strokeText(`x${levelData.scoreMultiplier}`, 0, currentDrawSize/2 + 12);
            ctx.fillText(`x${levelData.scoreMultiplier}`, 0, currentDrawSize/2 + 12);
        }
    } else {
        ctx.beginPath();
        ctx.arc(0, 0, (b.r * scale) + pulse, 0, Math.PI*2);
        ctx.fillStyle = b.color;
        ctx.fill();
    }
    ctx.restore();
}

function draw() {
    const logicalW = canvas.width / (window.devicePixelRatio || 1);
    const logicalH = canvas.height / (window.devicePixelRatio || 1);

    ctx.save();
    if (shakeTime > 0) ctx.translate((Math.random()-0.5)*shakeTime, (Math.random()-0.5)*shakeTime);
    ctx.clearRect(0, 0, logicalW, logicalH);

    Object.entries(ZONES).forEach(([key, z]) => {
        const isYellow = key === 'yellow';
        const gradient = ctx.createLinearGradient(isYellow ? z.x : z.x + z.w, z.y, isYellow ? z.x + z.w : z.x, z.y);
        gradient.addColorStop(0, z.glow);
        gradient.addColorStop(1, 'transparent');
        ctx.fillStyle = gradient;
        ctx.fillRect(z.x, z.y, z.w, z.h);
        ctx.strokeStyle = z.color;
        ctx.lineWidth = 3;
        ctx.beginPath();
        const lineX = isYellow ? z.x + z.w : z.x;
        ctx.moveTo(lineX, z.y); ctx.lineTo(lineX, z.y + z.h);
        ctx.stroke();

        ctx.setLineDash([8, 4]);
        ctx.lineWidth = 1; ctx.globalAlpha = 0.4;
        ctx.beginPath(); ctx.moveTo(z.x, z.y); ctx.lineTo(z.x + z.w, z.y); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(z.x, z.y + z.h); ctx.lineTo(z.x + z.w, z.y + z.h); ctx.stroke();
        ctx.setLineDash([]); ctx.globalAlpha = 1.0;
    });

    sortedBombs.yellow.forEach(b => drawBomb(b, true));
    sortedBombs.indigo.forEach(b => drawBomb(b, true));
    bombs.forEach(b => drawBomb(b, false));

    particles.forEach((p, i) => {
        ctx.globalAlpha = p.life;
        ctx.fillStyle = p.color;
        ctx.beginPath(); ctx.arc(p.x, p.y, p.r, 0, Math.PI*2); ctx.fill();
        p.x += p.vx; p.y += p.vy; p.life -= p.decay;
        if(p.life <= 0) particles.splice(i, 1);
    });

    floatingTexts.forEach((t, i) => {
        ctx.globalAlpha = t.life;
        ctx.fillStyle = t.color;
        ctx.font = `900 ${t.size}px 'Inter'`;
        ctx.textAlign = "center";
        ctx.fillText(t.text, t.x, t.y);
        t.y += t.vy; t.life -= 0.025;
        if(t.life <= 0) floatingTexts.splice(i, 1);
    });
    
    mergeEffects.forEach((e, i) => {
        ctx.globalAlpha = e.life * 0.6;
        ctx.strokeStyle = e.color;
        ctx.lineWidth = 4;
        ctx.beginPath();
        ctx.arc(e.x, e.y, e.radius, 0, Math.PI * 2);
        ctx.stroke();
        
        e.radius += (e.maxRadius - e.radius) * 0.15;
        e.life -= 0.04;
        if(e.life <= 0) mergeEffects.splice(i, 1);
    });
    
    ctx.restore();
    requestAnimationFrame((ts) => { update(ts); draw(); });
}

// ===== Interaction =====
const onStart = e => {
    if(gameState !== 'PLAYING') return; 
    const p = getPos(e);
    let target = null;
    let minDist = HIT_SLOP + BOMB_RADIUS;
    let targetIdx = -1;
    
    for(let i=bombs.length-1; i>=0; i--) {
        const b = bombs[i];
        const levelData = SIZE_LEVELS[b.sizeLevel];
        const adjustedRadius = (b.r * levelData.scale) + HIT_SLOP;
        const d = Math.hypot(p.x - b.x, p.y - b.y);
        if(d < adjustedRadius) { 
            minDist = d; 
            target = b; 
            targetIdx = i; 
            break;
        }
    }
    if(target) {
        dragging = target;
        touchOffset.x = p.x - target.x;
        touchOffset.y = p.y - target.y;
        dragging.vx = 0; dragging.vy = 0;
        bombs.splice(targetIdx, 1);
        bombs.push(target);
    }
};

const onMove = e => {
    const p = getPos(e);
    lastMousePos.x = mousePos.x;
    lastMousePos.y = mousePos.y;
    mousePos.x = p.x; 
    mousePos.y = p.y;
    
    if(!dragging || gameState !== 'PLAYING') return;
    
    const levelData = SIZE_LEVELS[dragging.sizeLevel];
    const dragWeight = levelData.dragWeight;
    
    const targetX = p.x - touchOffset.x;
    const targetY = p.y - touchOffset.y;
    
    dragging.x += (targetX - dragging.x) * dragWeight;
    dragging.y += (targetY - dragging.y) * dragWeight;
    
    if(e.cancelable) e.preventDefault();
};

let lastMergeCheck = 0;
const MERGE_CHECK_INTERVAL = 50;

function checkForMerges() {
    const now = Date.now();
    if (!dragging || now - lastMergeCheck < MERGE_CHECK_INTERVAL) return;
    lastMergeCheck = now;
    
    const mergeCheck = checkMerge(dragging);
    if (mergeCheck) {
        const mergedBomb = mergeBombs(dragging, mergeCheck.target, mergeCheck.index);
        dragging = mergedBomb;
        touchOffset.x = mousePos.x - mergedBomb.x;
        touchOffset.y = mousePos.y - mergedBomb.y;
        lastMergeCheck = now + MERGE_COOLDOWN;
    }
}

const onEnd = () => {
    if (!dragging || gameState !== 'PLAYING') return;
    checkZoneEntry(dragging);
    dragging = null;
};

function getPos(e) {
    const r = canvas.getBoundingClientRect();
    const cx = e.touches ? e.touches[0].clientX : e.clientX;
    const cy = e.touches ? e.touches[0].clientY : e.clientY;
    
    return {
        x: (cx - r.left),
        y: (cy - r.top)
    };
}

canvas.addEventListener("mousedown", onStart);
window.addEventListener("mousemove", onMove);
window.addEventListener("mouseup", onEnd);
canvas.addEventListener("touchstart", onStart, {passive:false});
window.addEventListener("touchmove", onMove, {passive:false});
window.addEventListener("touchend", onEnd);

// ===== Flow =====
function startGame() {
    score = 0; combo = 0;
    bombs = [];
    sortedBombs = { yellow: [], indigo: [] };
    finalCounts = { yellow: 0, indigo: 0 };
    particles = []; floatingTexts = []; mergeEffects = [];
    lastSpawn = performance.now();
    spawnInterval = 700;
    scoreEl.innerText = "0";
    comboEl.innerText = "0";
    comboGroup.classList.remove('active');
    updateRankUI();
    gameState = 'PLAYING';
    overlay.classList.add('hidden');
    resultBox.classList.add('hidden');
    statusTitle.innerHTML = "ELECTRO<br>RECOVERY";
    statusTitle.style.color = "white";
    statusMsg.innerHTML = "ドラッグして色を仕分けろ。<br>ミスは許されない。";
    resize();
}

function doGameOver(reason) {
    gameState = 'GAMEOVER';
    statusTitle.innerText = "SYSTEM FAILED";
    statusTitle.style.color = "var(--neon-red)";
    
    const rank = getRank(score);
    finalRankBox.innerText = rank.name;
    finalRankBox.style.color = rank.color;
    document.getElementById("res-yellow").innerText = finalCounts.yellow;
    document.getElementById("res-indigo").innerText = finalCounts.indigo;
    document.getElementById("res-total").innerText = finalCounts.yellow + finalCounts.indigo;
    
    resultBox.classList.remove('hidden');
    statusMsg.innerHTML = `<span style="color: #fff; font-weight: bold;">${reason}</span><br>FINAL SCORE: ${score}`;
    
    actionBtn.innerText = "REBOOT";
    overlay.classList.remove('hidden');
}

draw();
</script>
</body>
</html>