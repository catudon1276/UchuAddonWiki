<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>ELECTRO RECOVERY</title>
    <style>
        :root {
            --yellow-glow: #ffcc00;
            --indigo-glow: #3b5998;
            --accent-yellow: #ffcc00;
            --neon-red: #ff0044;
        }
        * {
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }
        html {
            height: 100%;
            overflow: hidden;
        }
        
        body {
            background: #050508;
            color: white;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            height: 100%;
            min-height: 100vh;
            min-height: -webkit-fill-available;
            margin: 0;
            padding: 0;
            font-family: 'Inter', 'Segoe UI', system-ui, sans-serif;
            overflow: hidden;
            touch-action: none;
            position: fixed;
            width: 100%;
        }

        .header-ui {
            width: 100%;
            min-height: 60px;
            max-height: 80px;
            height: 12vh;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 15px;
            background: linear-gradient(to bottom, rgba(255,255,255,0.03) 0%, transparent 100%);
            border-bottom: 1px solid rgba(255,255,255,0.08);
            z-index: 10;
            flex-shrink: 0;
            padding: 5px 10px;
        }

        .stat-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            min-width: 60px;
            flex: 0 1 auto;
        }

        .score-label { 
            font-size: 8px; 
            color: rgba(255,255,255,0.4); 
            text-transform: uppercase; 
            letter-spacing: 1px;
            margin-bottom: 1px;
            white-space: nowrap;
        }
        .score-val { 
            font-size: clamp(18px, 5vw, 28px);
            font-weight: 900; 
            font-variant-numeric: tabular-nums; 
        }

        #rank-display {
            font-size: clamp(16px, 4.5vw, 24px);
            font-weight: 900;
            font-style: italic;
        }
        
        #combo-group {
            transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            transform: scale(0);
            opacity: 0;
        }
        #combo-group.active {
            transform: scale(1);
            opacity: 1;
        }
        
        .rainbow-text {
            animation: rainbow 2s linear infinite;
        }
        @keyframes rainbow {
            0% { color: #ff0000; }
            20% { color: #ffff00; }
            40% { color: #00ff00; }
            60% { color: #00ffff; }
            80% { color: #0000ff; }
            100% { color: #ff00ff; }
        }

        #game-container {
            position: relative;
            width: 100%;
            flex: 1; 
            min-height: 0;
            background: #000;
            overflow: hidden;
            display: flex;
        }

        canvas {
            background: radial-gradient(circle at center, #0e0e12 0%, #000 100%);
            width: 100%;
            height: 100%;
            display: block;
            touch-action: none;
        }
        
        #overlay-screen {
            position: absolute;
            inset: 0;
            background: rgba(0,0,0,0.92);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
            transition: opacity 0.4s;
            backdrop-filter: blur(15px);
            padding: 20px;
        }
        h1 { 
            font-size: clamp(32px, 10vw, 48px);
            font-weight: 900; 
            margin: 0; 
            letter-spacing: -1px; 
            text-align: center; 
            line-height: 1.1;
            padding: 0 10px;
        }
        
        .rank-large {
            font-size: clamp(48px, 15vw, 80px);
            font-weight: 900;
            margin: 10px 0;
        }

        .result-stats {
            display: flex;
            gap: 10px;
            margin: 10px 0;
            padding: 10px 15px;
            background: rgba(255,255,255,0.05);
            border-radius: 8px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .res-item {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .res-label {
            font-size: 9px;
            color: rgba(255,255,255,0.4);
            text-transform: uppercase;
        }

        .res-val {
            font-size: clamp(16px, 4vw, 20px);
            font-weight: 900;
        }

        .btn {
            padding: 12px 30px;
            font-size: clamp(14px, 3.5vw, 18px);
            background: #fff;
            color: #000;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 900;
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-top: 10px;
        }
        .hidden { opacity: 0 !important; pointer-events: none !important; }

        /* Tablet/Desktop scale up */
        @media (min-width: 768px) {
            .header-ui { 
                height: 15vh;
                max-height: 100px; 
                gap: 60px; 
            }
            .score-val { font-size: 48px; }
            #rank-display { font-size: 32px; }
            h1 { font-size: 72px; }
            .rank-large { font-size: 120px; }
            .res-val { font-size: 32px; }
            .stat-group { min-width: 80px; }
        }
        
        /* Small mobile optimization */
        @media (max-width: 380px) {
            .header-ui {
                gap: 8px;
                padding: 5px;
            }
            .stat-group {
                min-width: 50px;
            }
            .score-label {
                font-size: 7px;
                letter-spacing: 0.5px;
            }
        }
    </style>
</head>
<body>

    <header class="header-ui">
        <div class="stat-group">
            <div class="score-label">SCORE</div>
            <div id="score" class="score-val">0</div>
        </div>
        <div class="stat-group">
            <div class="score-label">RANK</div>
            <div id="rank-display">C</div>
        </div>
        <div id="combo-group" class="stat-group">
            <div class="score-label">COMBO</div>
            <div id="combo" class="score-val" style="color: var(--accent-yellow);">0</div>
        </div>
    </header>

    <div id="game-container">
        <div id="overlay-screen">
            <h1 id="status-title">ELECTRO<br>RECOVERY</h1>
            
            <div id="result-box" class="hidden" style="display: flex; flex-direction: column; align-items: center; width: 100%;">
                <div id="final-rank-box" class="rank-large">C</div>
                <div class="result-stats">
                    <div class="res-item">
                        <div class="res-label">HIGH SCORE</div>
                        <div id="res-highscore" class="res-val" style="color: #ffd700;">0</div>
                    </div>
                    <div class="res-item">
                        <div class="res-label">MAX COMBO</div>
                        <div id="res-maxcombo" class="res-val" style="color: var(--accent-yellow);">0</div>
                    </div>
                </div>
                <div class="result-stats">
                    <div class="res-item">
                        <div class="res-label">HIJIKI</div>
                        <div id="res-yellow" class="res-val" style="color: var(--yellow-glow);">0</div>
                    </div>
                    <div class="res-item">
                        <div class="res-label">LOZ</div>
                        <div id="res-indigo" class="res-val" style="color: #5c7cfa;">0</div>
                    </div>
                    <div class="res-item">
                        <div class="res-label">TOTAL</div>
                        <div id="res-total" class="res-val">0</div>
                    </div>
                </div>
                <div style="margin-top: 10px; padding: 8px 16px; background: rgba(255,255,255,0.05); border-radius: 4px;">
                    <div class="res-label" style="margin-bottom: 4px;">DEVICE</div>
                    <div id="res-device" class="res-val" style="font-size: clamp(14px, 3.5vw, 18px); color: #aaa;">-</div>
                </div>
            </div>

            <p id="status-msg" style="color: #ccc; margin: 10px 0 20px; text-align: center; max-width: 90%; line-height: 1.5; font-size: clamp(12px, 3vw, 14px); padding: 0 15px;">
                ãƒ‰ãƒ©ãƒƒã‚°ã—ã¦è‰²ã‚’ä»•åˆ†ã‘ã‚ã€‚<br>ãƒŸã‚¹ã¯è¨±ã•ã‚Œãªã„ã€‚
            </p>
            <button class="btn" onclick="startGame()" id="action-btn">INITIALIZE</button>
        </div>
        <canvas id="game"></canvas>
    </div>

<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
const scoreEl = document.getElementById("score");
const comboEl = document.getElementById("combo");
const rankEl = document.getElementById("rank-display");
const comboGroup = document.getElementById("combo-group");
const overlay = document.getElementById("overlay-screen");
const statusTitle = document.getElementById("status-title");
const statusMsg = document.getElementById("status-msg");
const finalRankBox = document.getElementById("final-rank-box");
const resultBox = document.getElementById("result-box");
const actionBtn = document.getElementById("action-btn");

// ===== Asset Loading =====
const bombSprite = new Image();
bombSprite.src = "../resource/HjkBom.png"; 

let imgReady = false;
bombSprite.onload = () => { imgReady = true; };

// ===== Constants & Config =====
let ZONES = {};
const GRID = { padding: 35 }; 
const BOMB_RADIUS = 22;
const TILE_SIZE = 64; 
const DRAW_SIZE = 54; 
const HIT_SLOP = 50; 
const VISUAL_CAPACITY = 100;
const MERGE_DISTANCE = 100;
const BASE_SIZE_LEVELS = [
    { scale: 1.0, fuseBonus: 0, scoreMultiplier: 1, name: "Normal", dragWeight: 1.0 },
    { scale: 1.4, fuseBonus: 2000, scoreMultiplier: 5, name: "Big", dragWeight: 1.0 },
    { scale: 1.8, fuseBonus: 3000, scoreMultiplier: 12, name: "Huge", dragWeight: 0.7 },
    { scale: 2.2, fuseBonus: 4000, scoreMultiplier: 25, name: "Mega", dragWeight: 0.4 }
];

// å‹•çš„ã«ã‚µã‚¤ã‚ºãƒ¬ãƒ™ãƒ«ã‚’å–å¾—ã™ã‚‹é–¢æ•°
function getSizeLevel(level) {
    if (level < BASE_SIZE_LEVELS.length) {
        return BASE_SIZE_LEVELS[level];
    }
    // ãƒ¬ãƒ™ãƒ«4ä»¥é™ã¯å‹•çš„ã«ç”Ÿæˆ
    const extraLevels = level - BASE_SIZE_LEVELS.length + 1;
    return {
        scale: 2.2 + (extraLevels * 0.3),
        fuseBonus: 4000 + (extraLevels * 1000),
        scoreMultiplier: 25 + (extraLevels * 10),
        name: `Ultra${extraLevels}`,
        dragWeight: Math.max(0.1, 0.4 - (extraLevels * 0.05))
    };
}

const MERGE_COOLDOWN = 300; 

// ===== Game State =====
let gameState = 'START'; 
let bombs = [];
let sortedBombs = { yellow: [], indigo: [] };
let finalCounts = { yellow: 0, indigo: 0 };
let particles = [];
let floatingTexts = [];
let mergeEffects = [];
let dragging = null;
let mousePos = { x: 0, y: 0 };
let lastMousePos = { x: 0, y: 0 };
let touchOffset = { x: 0, y: 0 };
let score = 0;
let combo = 0;
let maxCombo = 0;
let highScore = 0;
let lastMatchTime = 0;
let lastSpawn = 0;
let spawnInterval = 1800;
let shakeTime = 0;
let vacuums = []; // æƒé™¤æ©Ÿã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®é…åˆ—
let lastVacuumSpawn = 0;
let beakers = []; // ğŸ§ªãƒ“ãƒ¼ã‚«ãƒ¼ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®é…åˆ—
let autoMergeLevel = 0; // æ°¸ç¶šçš„ãªè‡ªå‹•åˆä½“ãƒ¬ãƒ™ãƒ« (0=ãªã—, 1=Lv1åŒå£«, 2=Lv2åŒå£«...)
let beakerSchedule = [10000, 20000, 30000, 40000, 50000]; // ğŸ§ªå‡ºç¾ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«
let currentBeakerIndex = 0; // æ¬¡ã«å‡ºç¾ã™ã‚‹ğŸ§ªã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹

// ===== Rank System =====
function getRank(s) {
    if (s < 1000) return { name: "C", color: "#aaa" };
    if (s < 3000) return { name: "B", color: "#8f8" };
    if (s < 6000) return { name: "A", color: "#4af" };
    if (s < 12000) return { name: "S", color: "#f5f" };
    if (s < 20000) return { name: "SS", color: "#f22" };
    if (s < 30000) return { name: "SSS", color: "#ff0" };
    if (s < 45000) return { name: "SSS+", color: "#fff" };
    if (s < 65000) return { name: "X", color: "#ff8c00" }; 
    if (s < 90000) return { name: "XX", color: "#00ffcc" };
    if (s < 120000) return { name: "XXX", color: "#ff00ff" };
    const uNum = Math.floor((s - 120000) / 40000) + 1;
    return { name: `U${uNum}`, color: "#fff", special: true };
}

function updateRankUI() {
    const r = getRank(score);
    rankEl.innerText = r.name;
    if (r.special) {
        rankEl.style.background = "linear-gradient(45deg, #ff0, #f0f, #0ff)";
        rankEl.style.webkitTextFillColor = "transparent";
        rankEl.style.webkitBackgroundClip = "text";
        rankEl.classList.add('rainbow-text');
    } else {
        rankEl.style.background = "none";
        rankEl.style.webkitTextFillColor = r.color;
        rankEl.classList.remove('rainbow-text');
    }
}

// ===== Setup =====
function resize() {
    const container = document.getElementById("game-container");
    const dpr = window.devicePixelRatio || 1;
    const rect = container.getBoundingClientRect();
    
    canvas.width = rect.width * dpr;
    canvas.height = rect.height * dpr;
    ctx.scale(dpr, dpr);
    
    // UI layout scaling for mobile
    const logicalWidth = rect.width;
    const logicalHeight = rect.height;

    // PCç”»é¢ã§ã¯ä¸­å¤®ã®æ¹§ãç©ºé–“ã‚’å›ºå®šã‚µã‚¤ã‚ºã«
    const isPC = logicalWidth >= 768;
    let zoneW, spawnAreaWidth;
    
    if (isPC) {
        // PC/ã‚¿ãƒ–ãƒ¬ãƒƒãƒˆ: ä»•åˆ†ã‘ã‚¾ãƒ¼ãƒ³ã¯ç”»é¢ç«¯ã‹ã‚‰æ¹§ãå ´æ‰€ã®å¢ƒç•Œã¾ã§
        spawnAreaWidth = 400; // ä¸­å¤®ã®æ¹§ãç©ºé–“ã®å¹…ã‚’400pxã«å¤‰æ›´
        const spawnAreaLeft = (logicalWidth - spawnAreaWidth) / 2;
        const spawnAreaRight = (logicalWidth + spawnAreaWidth) / 2;
        
        zoneW = spawnAreaLeft; // å·¦ç«¯ã‹ã‚‰æ¹§ãå ´æ‰€ã¾ã§ã®å¹…
        
        ZONES = {
            yellow: { x: 0, y: 0, w: spawnAreaLeft, h: logicalHeight, color: '#ffcc00', glow: 'rgba(255, 204, 0, 0.15)' },
            indigo: { x: spawnAreaRight, y: 0, w: logicalWidth - spawnAreaRight, h: logicalHeight, color: '#3b5998', glow: 'rgba(59, 89, 152, 0.15)' }
        };
    } else {
        // ãƒ¢ãƒã‚¤ãƒ«: ä»•åˆ†ã‘ã‚¾ãƒ¼ãƒ³ã‚’ç”»é¢å¤–ã¾ã§æ‹¡å¼µï¼ˆæ…£æ€§å¯¾ç­–ï¼‰
        zoneW = Math.min(logicalWidth * 0.28, 180);
        const marginY = Math.max(20, logicalHeight * 0.08);
        const zoneH = logicalHeight - (marginY * 2);
        
        // åˆ¤å®šã‚¨ãƒªã‚¢ã‚’ç”»é¢å¤–500pxã¾ã§æ‹¡å¼µ
        const extendArea = 500;
        
        ZONES = {
            yellow: { 
                x: -extendArea, 
                y: -extendArea, 
                w: zoneW + extendArea, 
                h: logicalHeight + (extendArea * 2), 
                visualX: 0,
                visualY: marginY,
                visualW: zoneW,
                visualH: zoneH,
                color: '#ffcc00', 
                glow: 'rgba(255, 204, 0, 0.15)' 
            },
            indigo: { 
                x: logicalWidth - zoneW, 
                y: -extendArea, 
                w: zoneW + extendArea, 
                h: logicalHeight + (extendArea * 2),
                visualX: logicalWidth - zoneW,
                visualY: marginY,
                visualW: zoneW,
                visualH: zoneH,
                color: '#3b5998', 
                glow: 'rgba(59, 89, 152, 0.15)' 
            }
        };
    }

    // Update grid padding
    GRID.padding = Math.max(25, Math.min(35, zoneW / 4));
}

// Mobile viewport height fix
function setVH() {
    const vh = window.innerHeight * 0.01;
    document.documentElement.style.setProperty('--vh', `${vh}px`);
}

window.addEventListener('resize', () => {
    setVH();
    resize();
});
window.addEventListener('orientationchange', () => {
    setTimeout(() => {
        setVH();
        resize();
    }, 300);
});

setVH();
resize();

// ===== FX Utils =====
function createText(x, y, text, color, size = 24) {
    floatingTexts.push({ x, y, text, color, life: 1.0, vy: -1.5, size });
}

function createParticles(x, y, color, count = 10, speed = 8) {
    for (let i = 0; i < count; i++) {
        const ang = Math.random() * Math.PI * 2;
        const s = Math.random() * speed;
        particles.push({
            x, y,
            vx: Math.cos(ang) * s,
            vy: Math.sin(ang) * s,
            r: Math.random() * 3 + 1,
            color,
            life: 1.0,
            decay: 0.03 + Math.random() * 0.03
        });
    }
}

function applyShake(intensity = 10) {
    shakeTime = intensity;
}

function createBigExplosion(x, y) {
    applyShake(15);
    for (let i = 0; i < 30; i++) {
        const ang = Math.random() * Math.PI * 2;
        const s = Math.random() * 20;
        particles.push({
            x, y,
            vx: Math.cos(ang) * s,
            vy: Math.sin(ang) * s,
            r: Math.random() * 6 + 1,
            color: Math.random() > 0.3 ? "#ff4400" : (Math.random() > 0.5 ? "#ffcc00" : "#fff"),
            life: 1.0,
            decay: 0.02
        });
    }
}

function createMergeEffect(x, y, color) {
    mergeEffects.push({
        x, y,
        color,
        radius: 10,
        maxRadius: 60,
        life: 1.0
    });
    applyShake(8);
    createParticles(x, y, color, 20, 12);
}

async function triggerChainExplosionSequence(wrongZoneType, wrongBomb, reason) {
    if (gameState === 'EXPLODING' || gameState === 'GAMEOVER') return;
    gameState = 'EXPLODING';
    dragging = null; 

    finalCounts.yellow = sortedBombs.yellow.length;
    finalCounts.indigo = sortedBombs.indigo.length;

    sortedBombs[wrongZoneType].push(wrongBomb);
    const bombIdx = bombs.indexOf(wrongBomb);
    if (bombIdx > -1) bombs.splice(bombIdx, 1);

    const targetList = sortedBombs[wrongZoneType];
    ZONES[wrongZoneType].glow = 'rgba(255, 0, 40, 0.7)';

    const explosionLimit = Math.min(targetList.length, VISUAL_CAPACITY);
    for (let i = 0; i < explosionLimit; i++) {
        const b = targetList.pop();
        if (b) createBigExplosion(b.x, b.y);
        await new Promise(r => setTimeout(r, 40));
    }
    sortedBombs[wrongZoneType] = [];

    for (let i = bombs.length - 1; i >= 0; i--) {
        const b = bombs[i];
        createBigExplosion(b.x, b.y);
        bombs.splice(i, 1);
        if (i % 3 === 0) await new Promise(r => setTimeout(r, 10));
    }

    setTimeout(() => doGameOver(reason), 800);
}

// ===== Logic =====
function spawnBomb() {
    const logicalW = canvas.width / (window.devicePixelRatio || 1);
    const logicalH = canvas.height / (window.devicePixelRatio || 1);

    const isIndigo = Math.random() < 0.5;
    const type = isIndigo ? "indigo" : "yellow";
    const spriteIndex = isIndigo ? 1 : 0;
    
    // ç·©ã‚„ã‹ãªä¸Šã‹ã‚‰ã®ã‚¹ãƒãƒ¼ãƒ³ç¢ºç‡ä¸Šæ˜‡
    const topSpawnChance = score < 2000 ? 0.2 : Math.min(0.5, (score - 2000) / 20000);
    const spawnFromTop = Math.random() < topSpawnChance;
    
    const startY = spawnFromTop ? -40 : logicalH + 40;
    // é€Ÿåº¦ã‚‚ç·©ã‚„ã‹ã«ä¸Šæ˜‡
    const baseSpeed = 2.0 + score/12000;
    const vyBase = spawnFromTop ? baseSpeed : -baseSpeed;

    // ã‚¹ãƒãƒ¼ãƒ³ä½ç½®ã‚’ä¸­å¤®ã‚¨ãƒªã‚¢ã«é™å®šï¼ˆPCå¯¾å¿œï¼‰
    const isPC = logicalW >= 768;
    let spawnAreaWidth;
    
    if (isPC) {
        spawnAreaWidth = 400; // PC/ã‚¿ãƒ–ãƒ¬ãƒƒãƒˆã¯400px
    } else {
        // ãƒ¢ãƒã‚¤ãƒ«: ä¸¡ã‚µã‚¤ãƒ‰ã®ã‚¾ãƒ¼ãƒ³å¹…ã‚’å–å¾—
        const zoneW = Math.min(logicalW * 0.28, 180);
        spawnAreaWidth = logicalW - (zoneW * 2);
    }
    
    bombs.push({
        x: logicalW / 2 + (Math.random() - 0.5) * spawnAreaWidth,
        y: startY,
        vx: (Math.random() - 0.5) * (2.0 + score/15000),
        vy: vyBase + (Math.random() - 0.5) * 1.0,
        r: BOMB_RADIUS,
        type,
        spriteIndex, 
        born: Date.now(),
        fuseTime: Math.max(5000, 14000 - (score * 0.25)),
        wobble: Math.random() * Math.PI,
        color: type === 'yellow' ? '#ffcc00' : '#3b5998',
        sizeLevel: 0
    });
}

function getSortedPosition(type, index) {
    const zone = ZONES[type];
    // ãƒ¢ãƒã‚¤ãƒ«ã§ã¯visualãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚’ä½¿ç”¨
    const zoneX = zone.visualX !== undefined ? zone.visualX : zone.x;
    const zoneY = zone.visualY !== undefined ? zone.visualY : zone.y;
    const zoneW = zone.visualW !== undefined ? zone.visualW : zone.w;
    
    const cols = Math.floor((zoneW - 20) / GRID.padding);
    const visualIndex = index % VISUAL_CAPACITY;
    
    const col = visualIndex % Math.max(1, cols);
    const row = Math.floor(visualIndex / Math.max(1, cols));
    
    const startX = zoneX + 25;
    const startY = zoneY + 40;
    return {
        x: startX + (col * GRID.padding),
        y: startY + (row * GRID.padding)
    };
}

function checkMerge(draggedBomb) {
    if (!draggedBomb) return null;
    
    for (let i = bombs.length - 1; i >= 0; i--) {
        const b = bombs[i];
        if (b === draggedBomb) continue;
        
        const dist = Math.hypot(b.x - draggedBomb.x, b.y - draggedBomb.y);
        const levelData = getSizeLevel(b.sizeLevel);
        const mergeRadius = MERGE_DISTANCE * levelData.scale;
        
        // åŒã˜ã‚¿ã‚¤ãƒ—ã€åŒã˜ã‚µã‚¤ã‚ºãƒ¬ãƒ™ãƒ«ãªã‚‰åˆä½“å¯èƒ½
        // ğŸ§ªå–å¾—å‰: æ‰‹å‹•ãƒ‰ãƒ©ãƒƒã‚°ã§åˆä½“ï¼ˆã‚³ãƒ³ãƒœåŠæ¸›ï¼‰
        // ğŸ§ªå–å¾—å¾Œ: è‡ªå‹•åˆä½“ã‚‚ã§ãã‚‹ï¼ˆã‚³ãƒ³ãƒœç¶­æŒï¼‰
        if (dist < mergeRadius && 
            b.type === draggedBomb.type && 
            b.sizeLevel === draggedBomb.sizeLevel) {
            return { target: b, index: i };
        }
    }
    return null;
}

function mergeBombs(b1, b2, b2Index) {
    const newLevel = b1.sizeLevel + 1;
    const levelData = getSizeLevel(newLevel);
    
    bombs.splice(b2Index, 1);
    
    b1.sizeLevel = newLevel;
    b1.born = Date.now();
    b1.fuseTime = Math.max(4000, 14000 - (score * 0.3)) + levelData.fuseBonus;
    
    const mergeX = (b1.x + b2.x) / 2;
    const mergeY = (b1.y + b2.y) / 2;
    b1.x = mergeX;
    b1.y = mergeY;
    
    // ã‚³ãƒ³ãƒœã‚’åŠæ¸›
    if (combo > 0) {
        combo = Math.floor(combo / 2);
        comboEl.innerText = combo;
        if (combo <= 1) {
            comboGroup.classList.remove('active');
        }
    }
    
    createMergeEffect(mergeX, mergeY, b1.color);
    
    return b1;
}

const onStart = e => {
    if(gameState !== 'PLAYING') return; 
    const p = getPos(e);
    
    // ğŸ§ªãƒ“ãƒ¼ã‚«ãƒ¼ã®ã‚¯ãƒªãƒƒã‚¯åˆ¤å®š
    for (let i = beakers.length - 1; i >= 0; i--) {
        const beaker = beakers[i];
        const dist = Math.hypot(p.x - beaker.x, p.y - beaker.y);
        if (dist < beaker.radius + 20) {
            // æ°¸ç¶šçš„ã«è‡ªå‹•åˆä½“ãƒ¬ãƒ™ãƒ«ã‚¢ãƒƒãƒ—
            autoMergeLevel = beaker.level;
            currentBeakerIndex++; // æ¬¡ã®ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã¸
            
            createText(beaker.x, beaker.y - 40, `AUTO MERGE Lv${autoMergeLevel} UNLOCKED!`, "#ff66ff", 28);
            createText(beaker.x, beaker.y + 40, `PERMANENT UPGRADE`, "#fff", 20);
            applyShake(12);
            
            // ãƒ“ãƒ¼ã‚«ãƒ¼ã‚’å‰Šé™¤
            beakers.splice(i, 1);
            return;
        }
    }
    
    // æƒé™¤æ©Ÿã®ã‚¯ãƒªãƒƒã‚¯åˆ¤å®š
    for (let i = vacuums.length - 1; i >= 0; i--) {
        const vac = vacuums[i];
        const dist = Math.hypot(p.x - vac.x, p.y - vac.y);
        if (dist < vac.radius + 20) {
            // å‘¨å›²ã®ãƒœãƒ ã‚’å¸å
            const absorbRadius = 250;
            let absorbed = 0;
            
            for (let j = bombs.length - 1; j >= 0; j--) {
                const b = bombs[j];
                const bombDist = Math.hypot(b.x - vac.x, b.y - vac.y);
                if (bombDist < absorbRadius) {
                    // å¸åã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
                    createParticles(b.x, b.y, b.color, 15, 10);
                    bombs.splice(j, 1);
                    absorbed++;
                }
            }
            
            // ä»–ã®æƒé™¤æ©Ÿã‚‚å¸å
            for (let j = vacuums.length - 1; j >= 0; j--) {
                if (i === j) continue;
                const vac2 = vacuums[j];
                const vacDist = Math.hypot(vac2.x - vac.x, vac2.y - vac.y);
                if (vacDist < absorbRadius) {
                    createParticles(vac2.x, vac2.y, "#44ff44", 20, 12);
                    vacuums.splice(j, 1);
                    if (j < i) i--; // ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹èª¿æ•´
                    absorbed++;
                }
            }
            
            if (absorbed > 0) {
                createText(vac.x, vac.y - 40, `ABSORBED ${absorbed}!`, "#44ff44", 28);
                applyShake(10);
            }
            
            // ä½¿ç”¨ã—ãŸæƒé™¤æ©Ÿã‚’å‰Šé™¤
            vacuums.splice(i, 1);
            return;
        }
    }
    
    // ãƒœãƒ ã®ãƒ‰ãƒ©ãƒƒã‚°åˆ¤å®š
    let target = null;
    let minDist = HIT_SLOP + BOMB_RADIUS;
    let targetIdx = -1;
    
    for(let i=bombs.length-1; i>=0; i--) {
        const b = bombs[i];
        const levelData = getSizeLevel(b.sizeLevel);
        // å¤§ãã„ãƒœãƒ ã»ã©HIT_SLOPã‚’æ¸›ã‚‰ã—ã¦å¿ å®Ÿãªåˆ¤å®šã«
        const slopReduction = Math.min(b.sizeLevel * 10, HIT_SLOP - 10); // æœ€å¤§40å‰Šæ¸›
        const adjustedSlop = Math.max(10, HIT_SLOP - slopReduction);
        const adjustedRadius = (b.r * levelData.scale) + adjustedSlop;
        const d = Math.hypot(p.x - b.x, p.y - b.y);
        if(d < adjustedRadius) { 
            minDist = d; 
            target = b; 
            targetIdx = i; 
            break;
        }
    }
    if(target) {
        dragging = target;
        touchOffset.x = p.x - target.x;
        touchOffset.y = p.y - target.y;
        dragging.vx = 0; dragging.vy = 0;
        bombs.splice(targetIdx, 1);
        bombs.push(target);
    }
};

function checkZoneEntry(b) {
    const withinXYellow = b.x >= ZONES.yellow.x && b.x <= ZONES.yellow.x + ZONES.yellow.w;
    const withinXIndigo = b.x >= ZONES.indigo.x && b.x <= ZONES.indigo.x + ZONES.indigo.w;
    const withinY = b.y >= ZONES.yellow.y && b.y <= ZONES.yellow.y + ZONES.yellow.h;
    
    if (withinY && (withinXYellow || withinXIndigo)) {
        const zoneType = withinXYellow ? 'yellow' : 'indigo';
        
        if (b.type === zoneType) {
            const index = sortedBombs[zoneType].length;
            const targetPos = getSortedPosition(zoneType, index);
            b.x = targetPos.x; b.y = targetPos.y;

            sortedBombs[zoneType].push(b);
            const bombIdx = bombs.indexOf(b);
            if (bombIdx > -1) bombs.splice(bombIdx, 1);

            const levelData = getSizeLevel(b.sizeLevel);
            
            if (b.sizeLevel > 0) {
                // å¤§ãã„ãƒœãƒ¼ãƒ«ã§ã‚‚ã‚³ãƒ³ãƒœã¯ç¶™ç¶š
                combo++;
                lastMatchTime = Date.now();
                if (combo > maxCombo) maxCombo = combo;
                const megaPoints = 100 * levelData.scoreMultiplier;
                score += megaPoints;
                if (combo > 1) comboGroup.classList.add('active');
                createText(b.x, b.y, `+${megaPoints}`, "#ffff00", 32);
                createText(b.x, b.y - 40, `${levelData.name.toUpperCase()} BONUS!`, "#fff", 20);
                applyShake(12);
            } else {
                combo++;
                lastMatchTime = Date.now();
                if (combo > maxCombo) maxCombo = combo;
                const points = Math.floor(10 * (1 + combo * 0.1));
                score += points;
                if (combo > 1) comboGroup.classList.add('active');
                createText(b.x, b.y, `+${points}`, ZONES[zoneType].color);
            }
            
            const oldRank = getRank(score - (b.sizeLevel > 0 ? 100 * levelData.scoreMultiplier : Math.floor(10 * (1 + combo * 0.1)))).name;
            scoreEl.innerText = score;
            comboEl.innerText = combo;
            updateRankUI();

            if (oldRank !== getRank(score).name) {
                const logicalW = canvas.width / (window.devicePixelRatio || 1);
                const logicalH = canvas.height / (window.devicePixelRatio || 1);
                createText(logicalW/2, logicalH/2, "RANK UP!", "#fff", 40);
                applyShake(10);
            }

            createParticles(b.x, b.y, ZONES[zoneType].color, b.sizeLevel > 0 ? 15 : 8);
            return true;
        } else {
            triggerChainExplosionSequence(zoneType, b, "åŸå› ï¼šæ‰±ã„æ–¹ã‚’é–“é•ãˆãŸæœ«è·¯");
            return false;
        }
    }
    return false;
}

function update(ts) {
    if (gameState !== 'PLAYING' && gameState !== 'EXPLODING') return;

    const logicalW = canvas.width / (window.devicePixelRatio || 1);
    const logicalH = canvas.height / (window.devicePixelRatio || 1);

    // ã‚¹ãƒãƒ¼ãƒ³é–“éš”ã®è¨ˆç®—ï¼ˆé«˜å¾—ç‚¹ã§ã‚‚ã•ã‚‰ã«åŠ é€Ÿï¼‰
    // å…ˆã«spawnIntervalã‚’æ›´æ–°
    if (score < 16000) {
        spawnInterval = Math.max(400, 1200 - (score * 0.05));
    } else if (score < 50000) {
        spawnInterval = 400;
    } else {
        // 50000ç‚¹ä»¥é™ã¯ã•ã‚‰ã«åŠ é€Ÿ
        spawnInterval = Math.max(200, 400 - ((score - 50000) * 0.002));
    }
    
    // ã‚¹ãƒãƒ¼ãƒ³å®Ÿè¡Œ
    if (gameState === 'PLAYING' && ts - lastSpawn > spawnInterval) {
        spawnBomb();
        lastSpawn = ts;
    }

    // ğŸ§ªãƒ“ãƒ¼ã‚«ãƒ¼ã®ã‚¹ãƒãƒ¼ãƒ³ï¼ˆã‚¹ã‚³ã‚¢ãŒé–¾å€¤ã‚’è¶…ãˆãŸã‚‰ï¼‰
    if (gameState === 'PLAYING' && beakers.length === 0 && currentBeakerIndex < beakerSchedule.length) {
        const threshold = beakerSchedule[currentBeakerIndex];
        if (score >= threshold) {
            const isPC = logicalW >= 768;
            let spawnAreaWidth;
            
            if (isPC) {
                spawnAreaWidth = 400; // PC/ã‚¿ãƒ–ãƒ¬ãƒƒãƒˆã¯400px
            } else {
                // ãƒ¢ãƒã‚¤ãƒ«: ä¸¡ã‚µã‚¤ãƒ‰ã®ã‚¾ãƒ¼ãƒ³å¹…ã‚’å–å¾—
                const zoneW = Math.min(logicalW * 0.28, 180);
                spawnAreaWidth = logicalW - (zoneW * 2);
            }
            
            // ç¾åœ¨ã®autoMergeLevelã«åŸºã¥ã„ã¦æ¬¡ã®ãƒ¬ãƒ™ãƒ«ã‚’æ±ºå®š
            const nextLevel = autoMergeLevel + 1;
            
            beakers.push({
                x: logicalW / 2 + (Math.random() - 0.5) * spawnAreaWidth * 0.5,
                y: -50,
                vy: 4.0, // ã‚ˆã‚Šé€Ÿã
                radius: 30,
                born: Date.now(),
                level: nextLevel,
                scheduleIndex: currentBeakerIndex
            });
        }
    }

    // ğŸ§ªãƒ“ãƒ¼ã‚«ãƒ¼ã®ç§»å‹•ï¼ˆä¸Šã‹ã‚‰ä¸‹ã¸ç›´ç·šçš„ã«è½ã¡ã‚‹ï¼‰
    for (let i = beakers.length - 1; i >= 0; i--) {
        const beaker = beakers[i];
        beaker.y += beaker.vy;
        
        // ç”»é¢ä¸‹ã«å‡ºãŸã‚‰å‰Šé™¤ã—ã€æ¬¡ã®ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã«é€²ã‚€ï¼ˆå–ã‚Šé€ƒã—ï¼‰
        if (beaker.y > logicalH + 100) {
            beakers.splice(i, 1);
            // 5000ç‚¹å¾Œã«å†å‡ºç¾
            beakerSchedule.push(score + 5000);
        }
    }

    // æƒé™¤æ©Ÿã®ã‚¹ãƒãƒ¼ãƒ³ï¼ˆ20ç§’ï½40ç§’ã«1å›ï¼‰
    if (gameState === 'PLAYING' && ts - lastVacuumSpawn > 20000 + Math.random() * 20000) {
        const spawnFromTop = Math.random() < 0.5;
        const startY = spawnFromTop ? -50 : logicalH + 50;
        const baseSpeed = 1.5;
        const vyBase = spawnFromTop ? baseSpeed : -baseSpeed;
        
        // ã‚¹ãƒãƒ¼ãƒ³ä½ç½®ã‚’ä¸­å¤®ã‚¨ãƒªã‚¢ã«é™å®šï¼ˆPCå¯¾å¿œï¼‰
        const isPC = logicalW >= 768;
        let spawnAreaWidth;
        
        if (isPC) {
            spawnAreaWidth = 400; // PC/ã‚¿ãƒ–ãƒ¬ãƒƒãƒˆã¯400px
        } else {
            // ãƒ¢ãƒã‚¤ãƒ«: ä¸¡ã‚µã‚¤ãƒ‰ã®ã‚¾ãƒ¼ãƒ³å¹…ã‚’å–å¾—
            const zoneW = Math.min(logicalW * 0.28, 180);
            spawnAreaWidth = logicalW - (zoneW * 2);
        }
        
        vacuums.push({
            x: logicalW / 2 + (Math.random() - 0.5) * spawnAreaWidth,
            y: startY,
            vx: (Math.random() - 0.5) * 2.5,
            vy: vyBase + (Math.random() - 0.5) * 1.0,
            radius: 30,
            wobble: Math.random() * Math.PI,
            born: Date.now()
        });
        lastVacuumSpawn = ts;
    }

    // æƒé™¤æ©Ÿã®ç§»å‹•ï¼ˆãƒœãƒ ã¨åŒã˜å‹•ãï¼‰
    for (let i = vacuums.length - 1; i >= 0; i--) {
        const vac = vacuums[i];
        vac.x += vac.vx;
        vac.y += vac.vy;
        vac.vx += Math.sin(ts / 500 + vac.wobble) * 0.05;
        
        // æ¹§ãå ´æ‰€ã‚¨ãƒªã‚¢ã®å¢ƒç•Œã‚’è¨ˆç®—
        const isPC = logicalW >= 768;
        let spawnAreaLeft, spawnAreaRight;
        
        if (isPC) {
            const spawnAreaWidth = 400; // PC/ã‚¿ãƒ–ãƒ¬ãƒƒãƒˆã¯400px
            spawnAreaLeft = (logicalW - spawnAreaWidth) / 2;
            spawnAreaRight = (logicalW + spawnAreaWidth) / 2;
        } else {
            // ãƒ¢ãƒã‚¤ãƒ«: visualWã‚’ä½¿ã£ã¦æ­£ã—ã„å¢ƒç•Œã‚’è¨ˆç®—
            const visualZoneW = ZONES.yellow.visualW || ZONES.yellow.w;
            spawnAreaLeft = visualZoneW;
            spawnAreaRight = logicalW - visualZoneW;
        }
        
        // å£ã§è·³ã­è¿”ã‚‹ï¼ˆæ¹§ãå ´æ‰€ã‚¨ãƒªã‚¢å†…ã«åˆ¶é™ï¼‰
        if (vac.x < spawnAreaLeft + vac.radius) { 
            vac.vx = Math.abs(vac.vx); 
            vac.x = spawnAreaLeft + vac.radius; 
        }
        if (vac.x > spawnAreaRight - vac.radius) { 
            vac.vx = -Math.abs(vac.vx); 
            vac.x = spawnAreaRight - vac.radius; 
        }
        if (vac.y < vac.radius) {
            vac.vy = Math.abs(vac.vy);
            vac.y = vac.radius;
        }
        if (vac.y > logicalH - vac.radius) {
            vac.vy = -Math.abs(vac.vy);
            vac.y = logicalH - vac.radius;
        }
    }

    if (Date.now() - lastMatchTime > 3000) {
        combo = 0;
        comboGroup.classList.remove('active');
    }

    if (shakeTime > 0) shakeTime -= 1;
    
    // ğŸ§ªå–å¾—å¾Œã®è‡ªå‹•åˆä½“ãƒã‚§ãƒƒã‚¯ï¼ˆãƒ‰ãƒ©ãƒƒã‚°ä¸­ã§ãªã„ãƒœãƒ ã®ã¿ï¼‰
    if (autoMergeLevel > 0 && gameState === 'PLAYING') {
        for (let i = 0; i < bombs.length; i++) {
            const b1 = bombs[i];
            if (b1 === dragging || b1.sizeLevel > autoMergeLevel - 1) continue;
            
            for (let j = i + 1; j < bombs.length; j++) {
                const b2 = bombs[j];
                if (b2 === dragging || b2.sizeLevel > autoMergeLevel - 1) continue;
                if (b1.type !== b2.type || b1.sizeLevel !== b2.sizeLevel) continue;
                
                const dist = Math.hypot(b1.x - b2.x, b1.y - b2.y);
                const levelData = getSizeLevel(b1.sizeLevel);
                const mergeRadius = MERGE_DISTANCE * levelData.scale;
                
                if (dist < mergeRadius) {
                    // è‡ªå‹•åˆä½“ï¼ˆã‚³ãƒ³ãƒœã¯åˆ‡ã‚Œãªã„ï¼‰
                    const newLevel = b1.sizeLevel + 1;
                    const newLevelData = getSizeLevel(newLevel);
                    
                    bombs.splice(j, 1);
                    
                    b1.sizeLevel = newLevel;
                    b1.born = Date.now();
                    b1.fuseTime = Math.max(4000, 14000 - (score * 0.3)) + newLevelData.fuseBonus;
                    
                    const mergeX = (b1.x + b2.x) / 2;
                    const mergeY = (b1.y + b2.y) / 2;
                    b1.x = mergeX;
                    b1.y = mergeY;
                    
                    createMergeEffect(mergeX, mergeY, b1.color);
                    break; // 1ãƒ•ãƒ¬ãƒ¼ãƒ ã«1å›ã ã‘
                }
            }
        }
    }
    
    checkForMerges();

    // ãƒœãƒ åŒå£«ã®è¡çªåˆ¤å®šã¨åç™ºï¼ˆæœ€é©åŒ–ç‰ˆï¼‰
    for (let i = 0; i < bombs.length; i++) {
        const b1 = bombs[i];
        if (b1 === dragging) continue;
        
        for (let j = i + 1; j < bombs.length; j++) {
            const b2 = bombs[j];
            if (b2 === dragging) continue;
            
            const dx = b2.x - b1.x;
            const dy = b2.y - b1.y;
            const distSq = dx * dx + dy * dy; // å¹³æ–¹æ ¹è¨ˆç®—ã‚’é¿ã‘ã‚‹
            
            const levelData1 = getSizeLevel(b1.sizeLevel);
            const levelData2 = getSizeLevel(b2.sizeLevel);
            const r1 = b1.r * levelData1.scale;
            const r2 = b2.r * levelData2.scale;
            const minDist = r1 + r2;
            const minDistSq = minDist * minDist;
            
            // è¡çªã—ã¦ã„ã‚‹å ´åˆï¼ˆå¹³æ–¹æ ¹ãªã—ã§åˆ¤å®šï¼‰
            if (distSq < minDistSq && distSq > 0.01) {
                const dist = Math.sqrt(distSq); // ã“ã“ã§åˆã‚ã¦å¹³æ–¹æ ¹
                const overlap = minDist - dist;
                const nx = dx / dist;
                const ny = dy / dist;
                
                // è³ªé‡ï¼ˆã‚µã‚¤ã‚ºã«å¿œã˜ãŸé‡ã•ï¼‰
                const mass1 = levelData1.scale * levelData1.scale;
                const mass2 = levelData2.scale * levelData2.scale;
                const totalMass = mass1 + mass2;
                
                // ä½ç½®è£œæ­£ï¼ˆé‡ã„æ–¹ãŒå°‘ãªãå‹•ãï¼‰
                const push1 = overlap * (mass2 / totalMass);
                const push2 = overlap * (mass1 / totalMass);
                
                b1.x -= nx * push1;
                b1.y -= ny * push1;
                b2.x += nx * push2;
                b2.y += ny * push2;
                
                // é€Ÿåº¦ã®åç™ºï¼ˆå¼¾æ€§è¡çªï¼‰
                const dvx = b2.vx - b1.vx;
                const dvy = b2.vy - b1.vy;
                const dvn = dvx * nx + dvy * ny;
                
                if (dvn < 0) { // è¿‘ã¥ã„ã¦ã„ã‚‹å ´åˆã®ã¿åç™º
                    const restitution = 0.6; // åç™ºä¿‚æ•°
                    const impulse = (1 + restitution) * dvn / totalMass;
                    
                    b1.vx += impulse * mass2 * nx;
                    b1.vy += impulse * mass2 * ny;
                    b2.vx -= impulse * mass1 * nx;
                    b2.vy -= impulse * mass1 * ny;
                }
            }
        }
    }

    for (let i = bombs.length - 1; i >= 0; i--) {
        const b = bombs[i];
        
        // ç•°å¸¸ã«é€Ÿã„ãƒœãƒ ã‚’å‰Šé™¤ï¼ˆé€Ÿåº¦ãŒ10ä»¥ä¸Šï¼‰
        const speed = Math.sqrt(b.vx * b.vx + b.vy * b.vy);
        if (speed > 10) {
            console.warn('Removing fast bomb:', speed);
            bombs.splice(i, 1);
            continue;
        }
        
        if (b !== dragging) {
            b.x += b.vx;
            b.y += b.vy;
            b.vx += Math.sin(ts / 500 + b.wobble) * 0.05;

            const levelData = getSizeLevel(b.sizeLevel);
            const effectiveRadius = b.r * levelData.scale;

            // æ¹§ãå ´æ‰€ã‚¨ãƒªã‚¢ã®å¢ƒç•Œã‚’è¨ˆç®—ï¼ˆãƒ‰ãƒ©ãƒƒã‚°ä¸­ã§ãªã„ãƒœãƒ ã®ã¿ï¼‰
            const isPC = logicalW >= 768;
            let spawnAreaLeft, spawnAreaRight;
            
            if (isPC) {
                const spawnAreaWidth = 400; // PC/ã‚¿ãƒ–ãƒ¬ãƒƒãƒˆã¯400px
                spawnAreaLeft = (logicalW - spawnAreaWidth) / 2;
                spawnAreaRight = (logicalW + spawnAreaWidth) / 2;
            } else {
                // ãƒ¢ãƒã‚¤ãƒ«: visualWã‚’ä½¿ã£ã¦æ­£ã—ã„å¢ƒç•Œã‚’è¨ˆç®—
                const visualZoneW = ZONES.yellow.visualW || ZONES.yellow.w;
                spawnAreaLeft = visualZoneW;
                spawnAreaRight = logicalW - visualZoneW;
            }

            // å·¦å³ã®å¢ƒç•Œï¼ˆæ¹§ãå ´æ‰€ã‚¨ãƒªã‚¢å†…ã«åˆ¶é™ï¼‰
            if (b.x < spawnAreaLeft + effectiveRadius) { 
                b.vx = Math.abs(b.vx) * 0.8; // é€Ÿåº¦ã‚’å°‘ã—æ¸›è¡°
                b.x = spawnAreaLeft + effectiveRadius; 
            }
            if (b.x > spawnAreaRight - effectiveRadius) { 
                b.vx = -Math.abs(b.vx) * 0.8; // é€Ÿåº¦ã‚’å°‘ã—æ¸›è¡°
                b.x = spawnAreaRight - effectiveRadius; 
            }
            
            // ä¸Šä¸‹ã®å¢ƒç•Œ
            if (b.y < effectiveRadius) {
                b.vy = Math.abs(b.vy) * 0.8; // é€Ÿåº¦ã‚’å°‘ã—æ¸›è¡°
                b.y = effectiveRadius;
            }
            if (b.y > logicalH - effectiveRadius) {
                b.vy = -Math.abs(b.vy) * 0.8; // é€Ÿåº¦ã‚’å°‘ã—æ¸›è¡°
                b.y = logicalH - effectiveRadius;
            }
        }
        // ãƒ‰ãƒ©ãƒƒã‚°ä¸­ã¯åˆ¶é™ãªã—ï¼ˆç”»é¢å…¨ä½“ã‚’ç§»å‹•å¯èƒ½ï¼‰
        
        if (gameState === 'PLAYING' && Date.now() - b.born > b.fuseTime) {
            finalCounts.yellow = sortedBombs.yellow.length;
            finalCounts.indigo = sortedBombs.indigo.length;
            createBigExplosion(b.x, b.y);
            bombs.splice(i, 1);
            doGameOver("åŸå› ï¼šçªç„¶ã®è£åˆ‡ã‚Š");
        }
    }
}

// ===== Drawing =====
function drawBomb(b, isStatic = false) {
    const age = Date.now() - b.born;
    const isUrgent = !isStatic && age > b.fuseTime * 0.75;
    const pulse = (isUrgent && gameState === 'PLAYING') ? Math.sin(Date.now() / 40) * 4 : 0;
    const isHovered = !isStatic && !dragging && gameState === 'PLAYING' && Math.hypot(mousePos.x - b.x, mousePos.y - b.y) < b.r + HIT_SLOP;

    const levelData = getSizeLevel(b.sizeLevel);
    const scale = levelData.scale;

    ctx.save();
    ctx.translate(b.x, b.y);

    if (imgReady) {
        const currentDrawSize = (DRAW_SIZE * scale) + pulse * 2;
        const sx = b.spriteIndex * TILE_SIZE;
        const sy = 0;

        if (b.sizeLevel > 0 && gameState === 'PLAYING') {
            ctx.shadowColor = b.color;
            ctx.shadowBlur = 15 + Math.sin(Date.now() / 200) * 5;
        }

        ctx.drawImage(
            bombSprite, 
            sx, sy, TILE_SIZE, TILE_SIZE,  
            -currentDrawSize/2, -currentDrawSize/2, currentDrawSize, currentDrawSize 
        );
        
        ctx.shadowBlur = 0;
        
        if (isHovered && !('ontouchstart' in window)) {
            ctx.strokeStyle = "#fff";
            ctx.lineWidth = 2;
            ctx.strokeRect(-currentDrawSize/2, -currentDrawSize/2, currentDrawSize, currentDrawSize);
        }
    } else {
        ctx.beginPath();
        ctx.arc(0, 0, (b.r * scale) + pulse, 0, Math.PI*2);
        ctx.fillStyle = b.color;
        ctx.fill();
    }
    ctx.restore();
}

function draw() {
    const logicalW = canvas.width / (window.devicePixelRatio || 1);
    const logicalH = canvas.height / (window.devicePixelRatio || 1);

    ctx.save();
    if (shakeTime > 0) ctx.translate((Math.random()-0.5)*shakeTime, (Math.random()-0.5)*shakeTime);
    ctx.clearRect(0, 0, logicalW, logicalH);

    Object.entries(ZONES).forEach(([key, z]) => {
        // æç”»ç”¨ã®åº§æ¨™ï¼ˆãƒ¢ãƒã‚¤ãƒ«ã§ã¯visualãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚’ä½¿ç”¨ï¼‰
        const drawX = z.visualX !== undefined ? z.visualX : z.x;
        const drawY = z.visualY !== undefined ? z.visualY : z.y;
        const drawW = z.visualW !== undefined ? z.visualW : z.w;
        const drawH = z.visualH !== undefined ? z.visualH : z.h;
        
        const isYellow = key === 'yellow';
        const gradient = ctx.createLinearGradient(isYellow ? drawX : drawX + drawW, drawY, isYellow ? drawX + drawW : drawX, drawY);
        gradient.addColorStop(0, z.glow);
        gradient.addColorStop(1, 'transparent');
        ctx.fillStyle = gradient;
        ctx.fillRect(drawX, drawY, drawW, drawH);
        ctx.strokeStyle = z.color;
        ctx.lineWidth = 3;
        ctx.beginPath();
        const lineX = isYellow ? drawX + drawW : drawX;
        ctx.moveTo(lineX, drawY); ctx.lineTo(lineX, drawY + drawH);
        ctx.stroke();

        ctx.setLineDash([8, 4]);
        ctx.lineWidth = 1; ctx.globalAlpha = 0.4;
        ctx.beginPath(); ctx.moveTo(drawX, drawY); ctx.lineTo(drawX + drawW, drawY); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(drawX, drawY + drawH); ctx.lineTo(drawX + drawW, drawY + drawH); ctx.stroke();
        ctx.setLineDash([]); ctx.globalAlpha = 1.0;
    });

    sortedBombs.yellow.forEach(b => drawBomb(b, true));
    sortedBombs.indigo.forEach(b => drawBomb(b, true));
    bombs.forEach(b => drawBomb(b, false));

    // ğŸ§ªãƒ“ãƒ¼ã‚«ãƒ¼ã®æç”»
    beakers.forEach(beaker => {
        ctx.save();
        ctx.translate(beaker.x, beaker.y);
        
        // ãƒ“ãƒ¼ã‚«ãƒ¼ã®ã‚¢ã‚¤ã‚³ãƒ³
        ctx.fillStyle = "#ff66ff";
        ctx.strokeStyle = "#fff";
        ctx.lineWidth = 3;
        
        // æœ¬ä½“
        ctx.beginPath();
        ctx.arc(0, 0, beaker.radius, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();
        
        // ğŸ§ªãƒãƒ¼ã‚¯
        ctx.fillStyle = "#fff";
        ctx.font = "bold 28px Arial";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText("ğŸ§ª", 0, 0);
        
        // ãƒ¬ãƒ™ãƒ«è¡¨ç¤º
        ctx.font = "bold 14px Inter";
        ctx.fillStyle = "#fff";
        ctx.strokeStyle = "#000";
        ctx.lineWidth = 3;
        ctx.strokeText(`Lv${beaker.level}`, 0, beaker.radius + 18);
        ctx.fillText(`Lv${beaker.level}`, 0, beaker.radius + 18);
        
        // ãƒ›ãƒãƒ¼ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
        const dist = Math.hypot(mousePos.x - beaker.x, mousePos.y - beaker.y);
        if (dist < beaker.radius + 20) {
            ctx.strokeStyle = "#ffff00";
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.arc(0, 0, beaker.radius + 5, 0, Math.PI * 2);
            ctx.stroke();
        }
        
        ctx.restore();
    });

    // æƒé™¤æ©Ÿã®æç”»
    vacuums.forEach(vac => {
        ctx.save();
        ctx.translate(vac.x, vac.y);
        
        // æƒé™¤æ©Ÿã®ã‚¢ã‚¤ã‚³ãƒ³ï¼ˆç°¡æ˜“ç‰ˆï¼‰
        ctx.fillStyle = "#44ff44";
        ctx.strokeStyle = "#fff";
        ctx.lineWidth = 3;
        
        // æœ¬ä½“
        ctx.beginPath();
        ctx.arc(0, 0, vac.radius, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();
        
        // æƒé™¤æ©Ÿãƒãƒ¼ã‚¯
        ctx.fillStyle = "#fff";
        ctx.font = "bold 28px Arial";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText("ğŸ§¹", 0, 0);
        
        // ãƒ›ãƒãƒ¼ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
        const dist = Math.hypot(mousePos.x - vac.x, mousePos.y - vac.y);
        if (dist < vac.radius + 20) {
            ctx.strokeStyle = "#ffff00";
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.arc(0, 0, vac.radius + 5, 0, Math.PI * 2);
            ctx.stroke();
        }
        
        ctx.restore();
    });

    particles.forEach((p, i) => {
        ctx.globalAlpha = p.life;
        ctx.fillStyle = p.color;
        ctx.beginPath(); ctx.arc(p.x, p.y, p.r, 0, Math.PI*2); ctx.fill();
        p.x += p.vx; p.y += p.vy; p.life -= p.decay;
        if(p.life <= 0) particles.splice(i, 1);
    });

    floatingTexts.forEach((t, i) => {
        ctx.globalAlpha = t.life;
        ctx.fillStyle = t.color;
        ctx.font = `900 ${t.size}px 'Inter'`;
        ctx.textAlign = "center";
        ctx.fillText(t.text, t.x, t.y);
        t.y += t.vy; t.life -= 0.025;
        if(t.life <= 0) floatingTexts.splice(i, 1);
    });
    
    mergeEffects.forEach((e, i) => {
        ctx.globalAlpha = e.life * 0.6;
        ctx.strokeStyle = e.color;
        ctx.lineWidth = 4;
        ctx.beginPath();
        ctx.arc(e.x, e.y, e.radius, 0, Math.PI * 2);
        ctx.stroke();
        
        e.radius += (e.maxRadius - e.radius) * 0.15;
        e.life -= 0.04;
        if(e.life <= 0) mergeEffects.splice(i, 1);
    });
    
    ctx.restore();
    requestAnimationFrame((ts) => { update(ts); draw(); });
}

const onMove = e => {
    const p = getPos(e);
    lastMousePos.x = mousePos.x;
    lastMousePos.y = mousePos.y;
    mousePos.x = p.x; 
    mousePos.y = p.y;
    
    if(!dragging || gameState !== 'PLAYING') return;
    
    const levelData = getSizeLevel(dragging.sizeLevel);
    const dragWeight = levelData.dragWeight;
    
    const targetX = p.x - touchOffset.x;
    const targetY = p.y - touchOffset.y;
    
    dragging.x += (targetX - dragging.x) * dragWeight;
    dragging.y += (targetY - dragging.y) * dragWeight;
    
    if(e.cancelable) e.preventDefault();
};

let lastMergeCheck = 0;
const MERGE_CHECK_INTERVAL = 50;

function checkForMerges() {
    const now = Date.now();
    if (!dragging || now - lastMergeCheck < MERGE_CHECK_INTERVAL) return;
    lastMergeCheck = now;
    
    const mergeCheck = checkMerge(dragging);
    if (mergeCheck) {
        const mergedBomb = mergeBombs(dragging, mergeCheck.target, mergeCheck.index);
        dragging = mergedBomb;
        touchOffset.x = mousePos.x - mergedBomb.x;
        touchOffset.y = mousePos.y - mergedBomb.y;
        lastMergeCheck = now + MERGE_COOLDOWN;
    }
}

const onEnd = () => {
    if (!dragging || gameState !== 'PLAYING') return;
    checkZoneEntry(dragging);
    dragging = null;
};

function getPos(e) {
    const r = canvas.getBoundingClientRect();
    const cx = e.touches ? e.touches[0].clientX : e.clientX;
    const cy = e.touches ? e.touches[0].clientY : e.clientY;
    
    return {
        x: (cx - r.left),
        y: (cy - r.top)
    };
}

canvas.addEventListener("mousedown", onStart);
window.addEventListener("mousemove", onMove);
window.addEventListener("mouseup", onEnd);
canvas.addEventListener("touchstart", onStart, {passive:false});
window.addEventListener("touchmove", onMove, {passive:false});
window.addEventListener("touchend", onEnd);

// ===== Flow =====
function startGame() {
    score = 0; combo = 0; maxCombo = 0;
    bombs = [];
    sortedBombs = { yellow: [], indigo: [] };
    finalCounts = { yellow: 0, indigo: 0 };
    particles = []; floatingTexts = []; mergeEffects = [];
    vacuums = [];
    beakers = [];
    autoMergeLevel = 0;
    beakerSchedule = [10000, 20000, 30000, 40000, 50000];
    currentBeakerIndex = 0;
    lastSpawn = performance.now();
    lastVacuumSpawn = performance.now();
    spawnInterval = 1200;
    scoreEl.innerText = "0";
    comboEl.innerText = "0";
    comboGroup.classList.remove('active');
    updateRankUI();
    gameState = 'PLAYING';
    overlay.classList.add('hidden');
    resultBox.classList.add('hidden');
    statusTitle.innerHTML = "ELECTRO<br>RECOVERY";
    statusTitle.style.color = "white";
    statusMsg.innerHTML = "ãƒ‰ãƒ©ãƒƒã‚°ã—ã¦è‰²ã‚’ä»•åˆ†ã‘ã‚ã€‚<br>ãƒŸã‚¹ã¯è¨±ã•ã‚Œãªã„ã€‚";
    resize();
}

function doGameOver(reason) {
    gameState = 'GAMEOVER';
    statusTitle.innerText = "SYSTEM FAILED";
    statusTitle.style.color = "var(--neon-red)";
    
    // ãƒã‚¤ã‚¹ã‚³ã‚¢æ›´æ–°
    if (score > highScore) highScore = score;
    
    // ãƒ‡ãƒã‚¤ã‚¹åˆ¤å®š
    const logicalW = canvas.width / (window.devicePixelRatio || 1);
    const isPC = logicalW >= 768;
    const deviceName = isPC ? "PC" : "MOBILE";
    
    const rank = getRank(score);
    finalRankBox.innerText = rank.name;
    finalRankBox.style.color = rank.color;
    document.getElementById("res-highscore").innerText = highScore;
    document.getElementById("res-maxcombo").innerText = maxCombo;
    document.getElementById("res-yellow").innerText = finalCounts.yellow;
    document.getElementById("res-indigo").innerText = finalCounts.indigo;
    document.getElementById("res-total").innerText = finalCounts.yellow + finalCounts.indigo;
    document.getElementById("res-device").innerText = deviceName;
    
    resultBox.classList.remove('hidden');
    statusMsg.innerHTML = `<span style="color: #fff; font-weight: bold;">${reason}</span><br>FINAL SCORE: ${score}`;
    
    actionBtn.innerText = "REBOOT";
    overlay.classList.remove('hidden');
}

// ===== Button Events =====
actionBtn.addEventListener("click", () => {
    if (gameState === 'START' || gameState === 'GAMEOVER') {
        startGame();
    }
});

// ã‚¿ãƒ–ãƒ¬ãƒƒãƒˆ/ãƒ¢ãƒã‚¤ãƒ«å¯¾å¿œï¼šã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ã‚¯ãƒªãƒƒã‚¯ã§ã‚‚ã‚¹ã‚¿ãƒ¼ãƒˆ
overlay.addEventListener("click", (e) => {
    if (e.target === overlay && (gameState === 'START' || gameState === 'GAMEOVER')) {
        startGame();
    }
});

draw();
</script>
</body>
</html>