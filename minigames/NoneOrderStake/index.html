<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Night Of Schemes - ã‚¤ã‚«ã‚µãƒä¸Šç­‰ãƒãƒ³ãƒãƒ­</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@400;700;900&family=Noto+Serif+JP:wght@700;900&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="css/style.css">
</head>
<body>

    <!-- ã‚¿ã‚¤ãƒˆãƒ«ç”»é¢ -->
    <div id="title-screen" class="screen">
        <div class="title-container">
            <h1 class="title-logo">Night Of Schemes</h1>
            <p class="title-subtitle">ï½ã‚¤ã‚«ã‚µãƒä¸Šç­‰ï½</p>
            
            <div class="rules-box">
                <p class="rules-title">ã€ãƒ«ãƒ¼ãƒ«ã€‘</p>
                <p>ãƒ»ç›®æ¨™é‡‘é¡ <span class="text-green-400 font-bold">Â¥100,000</span> ã‚’é”æˆã›ã‚ˆ</p>
                <p>ãƒ»å…¨15è©¦åˆã‚’æˆ¦ã„æŠœã‘</p>
                <p>ãƒ»æ‰€æŒé‡‘ãŒ <span class="text-red-400 font-bold">Â¥100æœªæº€</span> ã§æ•—åŒ—</p>
                <p>ãƒ»åŒç‚¹ã®å ´åˆã¯CPUã®å‹ã¡</p>
                <p class="text-sm text-slate-400 mt-2">â€»ã‚«ãƒ¼ãƒ‰ã‚’é§†ä½¿ã—ã¦ã‚¤ã‚«ã‚µãƒã§å‹ã¦ï¼</p>
            </div>
            
            <div class="title-buttons">
                <button class="btn btn-primary" onclick="startCpuGame()">CPUå¯¾æˆ¦</button>
                <button class="btn btn-secondary" onclick="startOnlineGame()" disabled>
                    ã‚ªãƒ³ãƒ©ã‚¤ãƒ³å¯¾æˆ¦<span class="btn-sub">ï¼ˆé–‹ç™ºä¸­ï¼‰</span>
                </button>
            </div>
        </div>
    </div>

    <!-- ã‚²ãƒ¼ãƒ ç”»é¢ -->
    <div id="game-screen" class="screen hidden">
        <header class="game-header">
            <div class="header-left">
                <button id="rank-toggle" class="rank-toggle-btn">å½¹è¡¨</button>
            </div>
            <div class="header-center">
                <div class="match-info">
                    <span class="match-label">è©¦åˆ</span>
                    <span id="match-display" class="match-value">1/15</span>
                </div>
                <div class="mode-info">
                    <span id="mode-display" class="mode-value">é€šå¸¸è³½</span>
                </div>
            </div>
            <div class="header-right">
                <button id="card-draw-button" class="draw-btn" onclick="drawCard()">ã‚«ãƒ¼ãƒ‰ã‚’å¼•ã</button>
            </div>
        </header>

        <main class="game-main">
            <!-- CPUæƒ…å ± -->
            <div id="cpu-box" class="player-box cpu-box">
                <div class="box-header">
                    <div class="player-avatar cpu">CPU</div>
                    <div class="player-name">CPU</div>
                </div>
                <div class="box-stats">
                    <div class="stat-item"><span class="stat-label">æ‰€æŒé‡‘</span><span id="cpu-money" class="stat-value money">Â¥9,999,999</span></div>
                    <div class="stat-item"><span class="stat-label">æ›ã‘é‡‘</span><span id="cpu-bet" class="stat-value bet">Â¥0</span></div>
                </div>
                <div id="cpu-dice" class="dice-display"><div class="dice-slot">?</div><div class="dice-slot">?</div><div class="dice-slot">?</div></div>
                <div id="cpu-cards" class="card-backs"></div>
            </div>

            <!-- ä¸­å¤®ã‚¨ãƒªã‚¢ -->
            <div class="center-area">
                <div id="vfx-stage" class="vfx-stage"></div>
                <div id="bowl-area" class="bowl-area">
                    <div class="bowl-bg"></div>
                    <canvas id="dice-canvas"></canvas>
                </div>
                <div class="action-area">
                    <button id="action-button" class="btn btn-action hidden">ã‚µã‚¤ã‚³ãƒ­ã‚’æŒ¯ã‚‹</button>
                    <button id="skip-reroll-btn" class="btn btn-secondary hidden">ã“ã‚Œã§å‹è² </button>
                </div>
            </div>

            <!-- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼æƒ…å ± -->
            <div id="player-box" class="player-box player-box-self">
                <div class="box-header">
                    <div class="player-avatar you">YOU</div>
                    <div class="player-name">ã‚ãªãŸ</div>
                </div>
                <div class="box-stats">
                    <div class="stat-item"><span class="stat-label">æ‰€æŒé‡‘</span><span id="player-money" class="stat-value money">Â¥10,000</span></div>
                    <div class="stat-item"><span class="stat-label">æ›ã‘é‡‘</span><span id="player-bet" class="stat-value bet">Â¥0</span></div>
                </div>
                <div id="player-dice" class="dice-display"><div class="dice-slot">?</div><div class="dice-slot">?</div><div class="dice-slot">?</div></div>
            </div>
            <div id="player-cards" class="hand-area"></div>
        </main>

        <!-- å½¹è¡¨ãƒ‘ãƒãƒ« -->
        <aside id="rank-panel" class="rank-panel">
            <div class="rank-panel-header"><h2 class="rank-panel-title">å½¹è¡¨</h2><button onclick="document.getElementById('rank-panel').classList.remove('open')" class="close-btn">Ã—</button></div>
            <div id="dice-type-label" class="dice-type-label">é€šå¸¸è³½</div>
            <div id="rank-list" class="rank-list"></div>
            <div class="rank-info"><p id="info-text"><span class="text-yellow-500 font-bold">â—†</span> é»„è‰²ãŒãã®å½¹ã®ã€Œç›®ã€ã§ã™ã€‚</p></div>
        </aside>
        <div id="rank-overlay" class="rank-overlay" onclick="document.getElementById('rank-panel').classList.remove('open')"></div>
    </div>

    <!-- çµæœç”»é¢ -->
    <div id="result-screen" class="screen hidden">
        <div class="result-container">
            <h1 id="result-title" class="result-title victory">ğŸ‰ VICTORY! ğŸ‰</h1>
            <p class="result-label">æœ€çµ‚æ‰€æŒé‡‘</p>
            <p id="result-money" class="result-money">Â¥100,000</p>
            <button class="btn btn-primary" onclick="restartGame()">ã‚¿ã‚¤ãƒˆãƒ«ã¸</button>
        </div>
    </div>

    <!-- ãƒ¢ãƒ¼ãƒ€ãƒ«: ãƒ™ãƒƒãƒ†ã‚£ãƒ³ã‚° -->
    <div id="bet-modal" class="modal hidden">
        <div class="modal-content bet-modal-content">
            <h2 class="modal-title">è³­ã‘é‡‘ã‚’æ±ºã‚ã‚</h2>
            <div class="bet-slider-container">
                <input type="range" id="bet-slider" class="bet-slider" min="100" max="10000" value="1000" step="100">
                <div class="bet-value-display">Â¥<span id="bet-value">1,000</span></div>
            </div>
            <button class="btn btn-primary bet-confirm">æ±ºå®š</button>
        </div>
    </div>

    <!-- ãƒ¢ãƒ¼ãƒ€ãƒ«: ã‚«ãƒ¼ãƒ‰ä½¿ç”¨ç¢ºèª -->
    <div id="card-confirm-modal" class="modal hidden">
        <div class="modal-content card-confirm-content">
            <h2 id="confirm-card-name" class="modal-title">ã‚«ãƒ¼ãƒ‰å</h2>
            <p id="confirm-card-desc" class="card-desc">ã‚«ãƒ¼ãƒ‰ã®èª¬æ˜</p>
            <div class="modal-buttons">
                <button class="btn btn-secondary" onclick="document.getElementById('card-confirm-modal').classList.add('hidden')">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>
                <button class="btn btn-primary" onclick="confirmCardUse()">ä½¿ç”¨ã™ã‚‹</button>
            </div>
        </div>
    </div>

    <!-- ãƒ¢ãƒ¼ãƒ€ãƒ«: è©¦åˆçµæœ -->
    <div id="match-result-modal" class="modal hidden">
        <div class="modal-content match-result-content">
            <h2 id="match-winner" class="match-winner win">WIN!</h2>
            <div class="match-roles">
                <div class="role-box"><span class="role-label">ã‚ãªãŸ</span><span id="match-role-player" class="role-name">ãƒ”ãƒ³ã‚¾ãƒ­</span></div>
                <span class="vs">VS</span>
                <div class="role-box"><span class="role-label">CPU</span><span id="match-role-cpu" class="role-name">ã‚·ã‚´ãƒ­</span></div>
            </div>
            <p id="match-payout" class="match-payout">+Â¥5,000</p>
            <button id="next-match-btn" class="btn btn-primary">æ¬¡ã®è©¦åˆã¸</button>
        </div>
    </div>

    <!-- ãƒ€ã‚¤ã‚¹ç‰©ç†æ¼”ç®— -->
    <script>
        let diceGameState = {
            diceCount: 3, diceFaces: 6, diceLabels: null, bowlEnabled: true,
            bowlRadius: 90, bowlSafeRadius: 70, shonbenChance: 0.10,
            shonbenMinDice: 1, shonbenMaxDice: 3, diceSize: 32, normalVariance: 15, fixedVariance: 5
        };
        
        let DICE_SIZE = diceGameState.diceSize;
        let RADIUS = diceGameState.bowlRadius;
        let SAFE_RADIUS = diceGameState.bowlSafeRadius;
        let SHONBEN_CHANCE = diceGameState.shonbenChance;

        let diceCanvas, diceCtx;
        let dices = [];
        let isRolling = false;
        let shonbenRoute = false;
        let shonbenDiceIds = [];

        function setBowl(enabled) {
            diceGameState.bowlEnabled = enabled;
            const bowlEl = document.querySelector('.bowl-bg');
            if (bowlEl) bowlEl.style.display = enabled ? 'block' : 'none';
        }
        function setDiceFaces(faces) { diceGameState.diceFaces = faces; }
        function setDiceLabels(labels) { diceGameState.diceLabels = labels; }
        function setDiceCount(count) { if (!isRolling) { diceGameState.diceCount = count; resetDices(); } }
        function rollDice(direction) { startRoll(direction, 'normal'); }
        function rollWithValues(direction, values) {
            if (isRolling) return;
            isRolling = true; shonbenRoute = false; shonbenDiceIds = [];
            dices.forEach((d, i) => d.roll(direction, false, values[i] || null, false));
            checkRollComplete();
        }
        function rollShonben(direction) { startRoll(direction, 'force-shonben'); }

        function startRoll(direction, mode = 'normal') {
            if (isRolling) return;
            isRolling = true; shonbenRoute = false; shonbenDiceIds = [];
            let targetValues = new Array(diceGameState.diceCount).fill(null);
            
            if (mode === 'force-shonben') {
                shonbenRoute = true;
                const minC = Math.min(diceGameState.shonbenMinDice, diceGameState.diceCount);
                const maxC = Math.min(diceGameState.shonbenMaxDice, diceGameState.diceCount);
                const cnt = Math.floor(Math.random() * (maxC - minC + 1)) + minC;
                const ids = dices.map((_, i) => i);
                for (let i = ids.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [ids[i], ids[j]] = [ids[j], ids[i]]; }
                shonbenDiceIds = ids.slice(0, cnt);
            } else if (!diceGameState.bowlEnabled) {
                shonbenRoute = true;
                shonbenDiceIds = dices.map((_, i) => i);
            } else if (Math.random() < SHONBEN_CHANCE) {
                shonbenRoute = true;
                const minC = Math.min(diceGameState.shonbenMinDice, diceGameState.diceCount);
                const maxC = Math.min(diceGameState.shonbenMaxDice, diceGameState.diceCount);
                const cnt = Math.floor(Math.random() * (maxC - minC + 1)) + minC;
                const ids = dices.map((_, i) => i);
                for (let i = ids.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [ids[i], ids[j]] = [ids[j], ids[i]]; }
                shonbenDiceIds = ids.slice(0, cnt);
            }

            dices.forEach((d, i) => d.roll(direction, mode === 'force-shonben', targetValues[i], shonbenDiceIds.includes(i)));
            checkRollComplete();
        }

        function checkRollComplete() {
            const check = setInterval(() => {
                if (dices.every(d => d.isStopped)) {
                    clearInterval(check);
                    const shonben = dices.some(d => d.isShonben);
                    const results = dices.map(d => d.displayValue);
                    isRolling = false;
                    if (typeof window.onDiceRollComplete === 'function') window.onDiceRollComplete(results, shonben);
                }
            }, 100);
        }

        function resetDices() {
            dices = [];
            for (let i = 0; i < diceGameState.diceCount; i++) dices.push(new Dice(i));
        }

        class Dice {
            constructor(id) { this.id = id; this.reset(); }
            reset() {
                this.x = 0; this.y = 0; this.z = 0; this.vx = 0; this.vy = 0; this.vz = 0;
                this.angle = 0; this.va = 0; this.displayValue = Math.floor(Math.random() * diceGameState.diceFaces) + 1;
                this.targetValue = null; this.isValueFixed = false; this.isStopped = true;
                this.isShonben = false; this.shakeAmount = 0; this.fallScale = 1; this.opacity = 1;
            }
            roll(direction, forceShonben = false, targetValue = null, isShonbenTarget = false) {
                this.isStopped = false; this.isShonben = false; this.isValueFixed = false;
                this.targetValue = targetValue; this.fallScale = 1; this.opacity = 1;
                const centerX = diceCanvas.width / 2, centerY = diceCanvas.height / 2;
                let startX, startY, baseVx, baseVy;
                switch(direction) {
                    case 'top': startX = centerX + (Math.random() - 0.5) * 60; startY = -30; baseVx = (Math.random() - 0.5) * 2; baseVy = 6 + Math.random() * 3; break;
                    case 'bottom': startX = centerX + (Math.random() - 0.5) * 60; startY = diceCanvas.height + 30; baseVx = (Math.random() - 0.5) * 2; baseVy = -(6 + Math.random() * 3); break;
                    case 'left': startX = -30; startY = centerY + (Math.random() - 0.5) * 60; baseVx = 6 + Math.random() * 3; baseVy = (Math.random() - 0.5) * 2; break;
                    case 'right': startX = diceCanvas.width + 30; startY = centerY + (Math.random() - 0.5) * 60; baseVx = -(6 + Math.random() * 3); baseVy = (Math.random() - 0.5) * 2; break;
                    default: startX = centerX; startY = diceCanvas.height + 30; baseVx = 0; baseVy = -8;
                }
                this.x = startX; this.y = startY; this.z = 100;
                this.vx = baseVx + (Math.random() - 0.5) * 2; this.vy = baseVy + (Math.random() - 0.5) * 2; this.vz = -1.5;
                this.angle = Math.random() * Math.PI * 2; this.va = (Math.random() - 0.5) * 0.3;
                if (isShonbenTarget && !targetValue) { const a = Math.random() * Math.PI * 2; this.vx += Math.cos(a) * 4; this.vy += Math.sin(a) * 4; }
                if (targetValue) setTimeout(() => { this.displayValue = targetValue; this.isValueFixed = true; }, 200);
            }
            update() {
                if (this.isStopped) return;
                this.x += this.vx; this.y += this.vy; this.z += this.vz; this.angle += this.va;
                if (this.z <= 0 && !this.isValueFixed && !this.targetValue) this.displayValue = Math.floor(Math.random() * diceGameState.diceFaces) + 1;
                if (this.z <= 0) {
                    this.z = 0; this.vz = -this.vz * 0.3; this.vx *= 0.8; this.vy *= 0.8; this.va *= 0.6; this.shakeAmount = 4;
                    if (!this.isValueFixed && this.targetValue) { this.displayValue = this.targetValue; this.isValueFixed = true; }
                }
                const centerX = diceCanvas.width / 2, centerY = diceCanvas.height / 2;
                if (diceGameState.bowlEnabled) {
                    const dx = this.x - centerX, dy = this.y - centerY, dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist > RADIUS + 30 && !this.isShonben) { this.isShonben = true; this.opacity = 0.5; }
                    if (!this.isShonben && dist > SAFE_RADIUS) {
                        const nx = dx / dist, ny = dy / dist;
                        this.vx *= 0.6; this.vy *= 0.6;
                        const pf = (dist - SAFE_RADIUS) * 0.12;
                        this.vx -= nx * pf; this.vy -= ny * pf;
                        if (dist > RADIUS - DICE_SIZE / 2) { const o = dist - (RADIUS - DICE_SIZE / 2); this.x -= nx * o; this.y -= ny * o; }
                    }
                }
                dices.forEach(other => {
                    if (other === this || other.isStopped || other.isShonben) return;
                    const ddx = this.x - other.x, ddy = this.y - other.y, d2 = ddx * ddx + ddy * ddy, minD = DICE_SIZE * 0.85;
                    if (d2 < minD * minD && Math.abs(this.z - other.z) < 20) {
                        const d = Math.sqrt(d2) || 1, nx = ddx / d, ny = ddy / d, pf = 0.4;
                        this.vx += nx * pf; this.vy += ny * pf; other.vx -= nx * pf; other.vy -= ny * pf;
                    }
                });
                if (!this.isShonben && this.isValueFixed) {
                    const spd = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
                    if (spd < 0.1 && this.z < 1) { this.vx = 0; this.vy = 0; this.vz = 0; this.z = 0; this.isStopped = true; }
                }
                if (this.isShonben) { this.fallScale *= 0.97; this.opacity *= 0.96; if (this.opacity < 0.08) this.isStopped = true; }
            }
            draw() {
                if (this.opacity <= 0) return;
                diceCtx.globalAlpha = this.opacity;
                if (!this.isShonben) {
                    diceCtx.save(); diceCtx.translate(this.x, this.y);
                    const ss = (1 + this.z / 150) * this.fallScale; diceCtx.scale(ss, ss);
                    diceCtx.fillStyle = "rgba(0,0,0,0.12)"; diceCtx.beginPath(); diceCtx.roundRect(-DICE_SIZE/2 + 3, -DICE_SIZE/2 + 3, DICE_SIZE, DICE_SIZE, 8); diceCtx.fill();
                    diceCtx.restore();
                }
                diceCtx.save(); diceCtx.translate(this.x, this.y - this.z);
                if (this.shakeAmount > 0) { diceCtx.translate((Math.random()-0.5)*this.shakeAmount, (Math.random()-0.5)*this.shakeAmount); this.shakeAmount *= 0.8; }
                diceCtx.rotate(this.angle);
                const ds = (1 + this.z / 200) * this.fallScale; diceCtx.scale(ds, ds);
                this.drawDiceFace(this.displayValue);
                diceCtx.restore();
                diceCtx.globalAlpha = 1.0;
            }
            drawDiceFace(val) {
                const s = DICE_SIZE, r = 6;
                diceCtx.fillStyle = "#cbd5e1"; diceCtx.beginPath(); diceCtx.roundRect(-s/2, -s/2 + 3, s, s, r); diceCtx.fill();
                diceCtx.fillStyle = "#ffffff"; diceCtx.beginPath(); diceCtx.roundRect(-s/2, -s/2, s, s, r); diceCtx.fill();
                diceCtx.fillStyle = val === 1 ? "#e11d48" : "#1e293b";
                diceCtx.textAlign = "center"; diceCtx.textBaseline = "middle";
                diceCtx.font = `bold ${s * 0.6}px 'Arial'`; diceCtx.fillText(val, 0, 0);
            }
        }

        function animateDice() {
            if (!diceCtx) return;
            diceCtx.clearRect(0, 0, diceCanvas.width, diceCanvas.height);
            const sorted = [...dices].sort((a, b) => a.z - b.z);
            dices.forEach(d => d.update());
            sorted.forEach(d => d.draw());
            requestAnimationFrame(animateDice);
        }

        function initDiceCanvas() {
            diceCanvas = document.getElementById('dice-canvas');
            if (!diceCanvas) return;
            diceCtx = diceCanvas.getContext('2d');
            const ba = document.getElementById('bowl-area');
            if (ba) { const r = ba.getBoundingClientRect(); diceCanvas.width = r.width; diceCanvas.height = r.height; }
            else { diceCanvas.width = 200; diceCanvas.height = 200; }
            resetDices();
            animateDice();
        }

        window.DiceRoller = { setBowl, setDiceFaces, setDiceLabels, setDiceCount, rollDice, rollWithValues, rollShonben, isRolling: () => isRolling };
        document.addEventListener('DOMContentLoaded', initDiceCanvas);
    </script>

    <!-- VFXæ¼”å‡º -->
    <script>
        class MatchVFX {
            constructor(stageId) { this.stage = document.getElementById(stageId); }
            reset() { if (this.stage) { this.stage.innerHTML = ''; this.stage.className = 'vfx-stage'; } }
            triggerShake() { if (this.stage) { this.stage.classList.remove('shake'); void this.stage.offsetWidth; this.stage.classList.add('shake'); } }
            triggerFlash() { const f = document.createElement('div'); f.className = 'vfx-flash active'; this.stage?.appendChild(f); setTimeout(() => f.remove(), 400); }
            calcFontSize(text, baseSize = 4, minSize = 1.5) { const len = text.length; if (len <= 2) return `${baseSize}rem`; if (len <= 4) return `${baseSize * 0.7}rem`; if (len <= 6) return `${baseSize * 0.5}rem`; return `${Math.max(minSize, baseSize * (2.5 / len))}rem`; }
            async playPattern1(beforeText, afterText) {
                this.reset(); if (!this.stage) return;
                const c = document.createElement('div'); c.className = 'vfx-p1-container';
                const t1 = document.createElement('div'); t1.className = 'vfx-p1-turn-text'; t1.innerText = beforeText; t1.style.fontSize = this.calcFontSize(beforeText, 3);
                const sl = document.createElement('div'); sl.className = 'vfx-slash-line';
                const t2 = document.createElement('div'); t2.className = 'vfx-p1-final-text'; t2.innerText = afterText; t2.style.fontSize = this.calcFontSize(afterText, 5);
                c.appendChild(t1); c.appendChild(sl); c.appendChild(t2); this.stage.appendChild(c);
                await this._wait(200); t1.classList.add('active'); await this._wait(800);
                sl.classList.add('animate'); t1.classList.add('slash-hit'); this.triggerShake(); this.triggerFlash();
                await this._wait(200); t1.classList.remove('slash-hit'); t1.classList.add('dissolve');
                await this._wait(500); t2.classList.add('animate'); setTimeout(() => { this.triggerShake(); this.triggerFlash(); }, 50);
                await this._wait(1500); this.reset();
            }
            async playPattern2(text) {
                this.reset(); if (!this.stage) return;
                const c = document.createElement('div'); c.className = 'vfx-impact-container'; this.stage.appendChild(c);
                const fSize = this.calcFontSize(text, 4, 1);
                for (let ch of text.split('')) { const el = document.createElement('div'); el.className = 'vfx-char'; el.innerText = ch; el.style.fontSize = fSize; c.appendChild(el); await this._wait(80); el.classList.add('animate'); this.triggerShake(); }
                await this._wait(400); this.triggerFlash(); await this._wait(1000); this.reset();
            }
            async playPattern3(beforeText, afterText) {
                this.reset(); if (!this.stage) return;
                const c = document.createElement('div'); c.className = 'vfx-push-container';
                const fSize = this.calcFontSize(beforeText.length > afterText.length ? beforeText : afterText, 4);
                const t1 = document.createElement('div'); t1.className = 'vfx-push-text'; t1.innerText = beforeText; t1.style.fontSize = fSize;
                const t2 = document.createElement('div'); t2.className = 'vfx-push-text in-initial'; t2.innerText = afterText; t2.style.fontSize = fSize;
                c.appendChild(t1); c.appendChild(t2); this.stage.appendChild(c);
                await this._wait(100); t1.classList.add('visible'); await this._wait(1000);
                t1.classList.add('out'); t2.classList.remove('in-initial'); t2.classList.add('in-active');
                setTimeout(() => this.triggerShake(), 500);
                await this._wait(1500); this.reset();
            }
            _wait(ms) { return new Promise(resolve => setTimeout(resolve, ms)); }
        }
        window.MatchVFX = MatchVFX;
    </script>

    <!-- å½¹è¡¨ã‚·ã‚¹ãƒ†ãƒ  -->
    <script>
        const RankSystem = {
            currentDiceName: "é€šå¸¸è³½", infoMessage: `<span class="text-yellow-500 font-bold">â—†</span> é»„è‰²ãŒãã®å½¹ã®ã€Œç›®ã€ã§ã™ã€‚`, ranks: [],
            clear() { this.ranks = []; },
            addSection(label) { this.ranks.push({ type: 'label', text: label }); },
            addRank(name, mult, dice, targetIndex = -1, isSpecial = false) { this.ranks.push({ type: 'rank', name, mult, dice, t: targetIndex, isSpecial }); },
            setDiceName(name) { this.currentDiceName = name; const el = document.getElementById('dice-type-label'); if(el) el.innerText = name; },
            setInfoText(html) { this.infoMessage = html; const el = document.getElementById('info-text'); if(el) el.innerHTML = html; },
            render() {
                const list = document.getElementById('rank-list'); if (!list) return;
                list.innerHTML = this.ranks.map(r => {
                    if (r.type === 'label') return `<div class="rank-section-label"><span>${r.text}</span></div>`;
                    let dHtml;
                    if (r.isSpecial) dHtml = `<div class="rank-die dim">?</div><div class="rank-die dim">?</div><div class="rank-die dim">?</div>`;
                    else dHtml = r.dice.map((d, i) => { const isRed = (d === 1 && r.t !== i); const isTarget = (r.t === i); return `<div class="rank-die ${isTarget ? 'target' : ''} ${isRed ? 'red' : ''}">${d}</div>`; }).join('');
                    const multDisplay = r.mult > 0 ? `x${r.mult}` : `x${r.mult}`;
                    const multClass = r.mult < 0 ? 'negative' : '';
                    return `<div class="rank-item"><div class="rank-dice-container">${dHtml}</div><div class="rank-info"><div class="rank-name">${r.name}</div><div class="rank-mult ${multClass}">${multDisplay}</div></div></div>`;
                }).join('');
                this.setDiceName(this.currentDiceName); this.setInfoText(this.infoMessage);
            }
        };
        window.RankSystem = RankSystem;
    </script>

    <script type="module" src="js/main.js"></script>
</body>
</html>
