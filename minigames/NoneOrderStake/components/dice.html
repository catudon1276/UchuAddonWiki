<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2D Dice Roller - APIÁâà</title>
    <!--
    ========================================
    üéÆ ÂÖ¨ÈñãAPIÈñ¢Êï∞„É™„Éï„Ç°„É¨„É≥„Çπ
    ========================================
    
    „ÄêÂü∫Êú¨Ë®≠ÂÆö„Äë
    
    1. setBowl(enabled)
       Áöø„ÅÆË°®Á§∫/ÈùûË°®Á§∫„ÇíË®≠ÂÆö
       - enabled: true=Áöø„ÅÇ„Çä, false=Áöø„Å™„ÅóÔºàÂÖ®ÈÉ®ËêΩ„Å°„ÇãÔºâ
       ‰æã: setBowl(false);
    
    2. setDiceFaces(faces)
       „Çµ„Ç§„Ç≥„É≠„ÅÆÈù¢Êï∞„ÇíË®≠ÂÆö
       - faces: Èù¢Êï∞Ôºà3, 6, 10, 20„Å™„Å©‰ªªÊÑè„ÅÆÊï∞Ôºâ
       ‰æã: setDiceFaces(10);  // 10Èù¢„ÉÄ„Ç§„Çπ
    
    3. setDiceLabels(labels)
       „Çµ„Ç§„Ç≥„É≠„Å´„Ç´„Çπ„Çø„É†ÊñáÂ≠ó„ÇíË®≠ÂÆöÔºàÁîªÂÉèÂØæÂøú‰∫àÂÆöÔºâ
       - labels: ÊñáÂ≠ó„ÅÆÈÖçÂàó„ÄÅ„Åæ„Åü„ÅØnull„ÅßÊï∞Â≠ó„Å´Êàª„Åô
       ‰æã: setDiceLabels(['H','A','G','V','B','C']);
       ‰æã: setDiceLabels(null);  // Êï∞Â≠ó„Å´Êàª„Åô
       
       ‚Äª ÈÖçÂàó„ÅÆÈï∑„Åï = Èù¢Êï∞ „ÅåÊé®Â•®
       ‚Äª 7ÊñáÂ≠ó‰ª•‰∏ä„ÇÇÂØæÂøúÂèØËÉΩÔºà‰æã: 10ÊñáÂ≠óÈÖçÂàó + 10Èù¢„ÉÄ„Ç§„ÇπÔºâ
    
    4. setDiceSpriteSheet(urlOrConfig, frameWidth, frameHeight, frames, direction)
       „Çπ„Éó„É©„Ç§„Éà„Ç∑„Éº„ÉàÁîªÂÉè„ÇíË®≠ÂÆö
       - urlOrConfig: ÁîªÂÉèURL„Åæ„Åü„ÅØË®≠ÂÆö„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà
       - frameWidth: 1„Ç≥„Éû„ÅÆÂπÖÔºàURLÊåáÂÆöÊôÇÔºâ
       - frameHeight: 1„Ç≥„Éû„ÅÆÈ´ò„ÅïÔºàURLÊåáÂÆöÊôÇÔºâ
       - frames: „Ç≥„ÉûÊï∞ÔºàURLÊåáÂÆöÊôÇÔºâ
       - direction: 'vertical'ÔºàÁ∏¶Ôºâ„Åæ„Åü„ÅØ'horizontal'ÔºàÊ®™Ôºâ„ÄÅ„Éá„Éï„Ç©„É´„Éà='vertical'
       
       Á∞°ÊòìÂΩ¢Âºè:
       ‰æã: setDiceSpriteSheet('dice.png', 60, 60, 6);  // 60x360„ÅÆÁ∏¶‰∏¶„Å≥
       ‰æã: setDiceSpriteSheet('dice.png', 60, 60, 6, 'horizontal');  // 360x60„ÅÆÊ®™‰∏¶„Å≥
       
       „Ç™„Éñ„Ç∏„Çß„ÇØ„ÉàÂΩ¢Âºè:
       ‰æã: setDiceSpriteSheet({
             url: 'dice.png',
             frameWidth: 60,
             frameHeight: 60,
             frames: 6,
             direction: 'vertical'
           });
       
       „ÇØ„É™„Ç¢:
       ‰æã: setDiceSpriteSheet(null);  // „Çπ„Éó„É©„Ç§„Éà„Ç∑„Éº„Éà„ÇíËß£Èô§
    
    5. setDiceCount(count)
       „Çµ„Ç§„Ç≥„É≠„ÅÆÊï∞„ÇíË®≠ÂÆö
       - count: „Çµ„Ç§„Ç≥„É≠„ÅÆÂÄãÊï∞
       ‰æã: setDiceCount(5);
    
    „Äê„Çµ„Ç§„Ç≥„É≠„ÇíÊåØ„Çã„Äë
    
    6. rollDice(direction)
       ÈÄöÂ∏∏„ÅÆ„É©„É≥„ÉÄ„É†ÊåØ„Çä
       - direction: 'bottom', 'top', 'left', 'right'
       ‰æã: rollDice('bottom');
    
    7. rollWithValues(direction, values)
       ÊåáÂÆö„Åó„ÅüÁõÆ„Åß„Çµ„Ç§„Ç≥„É≠„ÇíÊåØ„Çã
       - direction: 'bottom', 'top', 'left', 'right'
       - values: Âá∫„Åó„Åü„ÅÑÁõÆ„ÅÆÈÖçÂàó [3, 5, 2]
       ‰æã: rollWithValues('bottom', [1, 4, 6]);
       
       ‚Äª „Ç´„Çπ„Çø„É†ÊñáÂ≠ó‰ΩøÁî®ÊôÇ„ÇÇÊï∞Â≠ó„ÅßÊåáÂÆö
       „ÄÄ ‰æã: ['H','A','G','V','B','C']„ÅÆÂ†¥Âêà
       „ÄÄ     [1, 4, 6] = H, V, C
       ‚Äª „ÄêÈáçË¶Å„ÄëÁöø„Å™„ÅóÊôÇ„ÅØÊåáÂÆöÂÄ§„Çà„ÇäÂÑ™ÂÖà„Åó„Å¶„Ç∑„Éß„É≥„Éô„É≥„Å´„Å™„Çä„Åæ„Åô
    
    8. rollShonben(direction)
       Âº∑Âà∂„Ç∑„Éß„É≥„Éô„É≥Ôºà„É©„É≥„ÉÄ„É†„Åß1„Äú3ÂÄã„ÅåËêΩ„Å°„ÇãÔºâ
       - direction: 'bottom', 'top', 'left', 'right'
       ‰æã: rollShonben('right');
    
    ========================================
    ‰ΩøÁî®‰æã
    ========================================
    
    // ‰æã1: H,A,G,V,B,C„ÅÆ6Èù¢„ÉÄ„Ç§„Çπ„Çí3ÂÄã„ÄÅÁöø„Å™„Åó„ÅßÊåØ„Çã
    setDiceLabels(['H','A','G','V','B','C']);
    setDiceCount(3);
    setBowl(false);
    rollDice('bottom');
    
    // ‰æã2: ÁâπÂÆö„ÅÆÁõÆ„ÇíÂá∫„ÅôÔºàH, V, CÔºâ
    rollWithValues('bottom', [1, 4, 6]);
    
    // ‰æã3: 10Èù¢„ÉÄ„Ç§„Çπ„Çí5ÂÄã
    setDiceFaces(10);
    setDiceCount(5);
    rollDice('top');
    
    // ‰æã4: „Çπ„Éó„É©„Ç§„Éà„Ç∑„Éº„Éà„Çí‰ΩøÁî®Ôºà60x360„ÅÆÁ∏¶‰∏¶„Å≥ÁîªÂÉèÔºâ
    setDiceSpriteSheet('images/dice-sprite.png', 60, 60, 6);
    rollDice('bottom');
    
    // ‰æã5: „Çπ„Éó„É©„Ç§„Éà„Ç∑„Éº„Éà„ÇíËß£Èô§„Åó„Å¶Êï∞Â≠ó„Å´Êàª„Åô
    setDiceSpriteSheet(null);
    setDiceLabels(null);
    setDiceFaces(6);
    setDiceCount(3);
    
    // ‰æã6: Áöø„Å™„Åó„É¢„Éº„ÉâÔºàÊåáÂÆöÂÄ§„Çà„ÇäÂÑ™ÂÖàÔºâ
    setBowl(false);
    rollWithValues('bottom', [6, 6, 6]);  // ÊåáÂÆö„Åó„Å¶„ÇÇÂÖ®ÈÉ®ËêΩ„Å°„Çã
    
    ========================================
    -->
    <style>
        body { margin: 0; overflow: hidden; background-color: #0f172a; font-family: 'sans-serif'; }
        #canvas-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .bowl-bg {
            position: absolute;
            width: 480px;
            height: 480px;
            border-radius: 50%;
            background: radial-gradient(circle, #b91c1c 0%, #7f1d1d 75%, #450a0a 100%);
            box-shadow: 0 0 80px rgba(0,0,0,0.6);
            z-index: 0;
            border: 4px solid rgba(255,255,255,0.1);
        }
        canvas { position: relative; z-index: 10; }
        #ui {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            display: flex; flex-direction: column; justify-content: flex-start; align-items: center;
            padding: 2.5rem;
            z-index: 20;
        }
        #result-display {
            font-size: 5rem; font-weight: 900; color: white;
            text-shadow: 0 0 30px rgba(255,255,255,0.4), 0 8px 0 #1e293b;
            opacity: 0; transform: scale(0.5) translateY(-20px);
            transition: all 0.6s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            max-width: 90%;
            word-break: break-word;
        }
        #result-display.show { opacity: 1; transform: scale(1) translateY(0); }
        #result-display.shonben { color: #facc15; text-shadow: 0 0 20px rgba(250, 204, 21, 0.5); }
    </style>
</head>
<body>

    <div id="canvas-container">
        <div class="bowl-bg" id="bowl-bg"></div>
        <canvas id="diceCanvas"></canvas>
        
        <div id="ui">
            <div id="result-display"></div>
        </div>
    </div>

    <script>
        // ========================================
        // üéÆ „Ç≤„Éº„É†Áä∂ÊÖã
        // ========================================
        let gameState = {
            diceCount: 3,
            diceFaces: 6,
            diceLabels: null,  // null = Êï∞Â≠ó, ['H','A','G'] = „Ç´„Çπ„Çø„É†ÊñáÂ≠ó
            diceSpriteSheet: null,  // „Çπ„Éó„É©„Ç§„Éà„Ç∑„Éº„ÉàË®≠ÂÆö
            bowlEnabled: true,
            bowlRadius: 220,
            bowlSafeRadius: 180,
            shonbenChance: 0.15,
            shonbenMinDice: 1,
            shonbenMaxDice: 3,
            diceSize: 48,
            normalVariance: 20,
            fixedVariance: 5
        };
        
        let DICE_SIZE = gameState.diceSize;
        let RADIUS = gameState.bowlRadius;
        let SAFE_RADIUS = gameState.bowlSafeRadius;
        let NORMAL_VARIANCE = gameState.normalVariance;
        let FIXED_VARIANCE = gameState.fixedVariance;
        let SHONBEN_CHANCE = gameState.shonbenChance;

        // „Çπ„Éó„É©„Ç§„Éà„Ç∑„Éº„ÉàÁîªÂÉè„ÅÆÁÆ°ÁêÜ
        let spriteImage = null;
        let spriteImageLoaded = false;

        // ========================================
        // üîß ÂÖ¨ÈñãAPIÈñ¢Êï∞
        // ========================================
        
        /**
         * Áöø„ÅÆË°®Á§∫/ÈùûË°®Á§∫„ÇíË®≠ÂÆö
         * @param {boolean} enabled - true=Áöø„ÅÇ„Çä, false=Áöø„Å™„Åó
         */
        function setBowl(enabled) {
            gameState.bowlEnabled = enabled;
            const bowlElement = document.getElementById('bowl-bg');
            bowlElement.style.display = enabled ? 'block' : 'none';
        }
        
        /**
         * „Çµ„Ç§„Ç≥„É≠„ÅÆÈù¢Êï∞„ÇíË®≠ÂÆö
         * @param {number} faces - Èù¢Êï∞Ôºà3, 6, 10, 20„Å™„Å©Ôºâ
         */
        function setDiceFaces(faces) {
            gameState.diceFaces = faces;
        }
        
        /**
         * „Çµ„Ç§„Ç≥„É≠„Å´„Ç´„Çπ„Çø„É†ÊñáÂ≠ó„ÇíË®≠ÂÆö
         * @param {Array|null} labels - ÊñáÂ≠ó„ÅÆÈÖçÂàó ['H','A','G'] „Åæ„Åü„ÅØ nullÔºàÊï∞Â≠ó„Å´Êàª„ÅôÔºâ
         */
        function setDiceLabels(labels) {
            gameState.diceLabels = labels;
        }
        
        /**
         * „Çπ„Éó„É©„Ç§„Éà„Ç∑„Éº„Éà„ÇíË®≠ÂÆö
         * @param {string|Object} urlOrConfig - ÁîªÂÉèURL„Åæ„Åü„ÅØË®≠ÂÆö„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà
         * @param {number} frameWidth - 1„Ç≥„Éû„ÅÆÂπÖÔºàURLÊåáÂÆöÊôÇÔºâ
         * @param {number} frameHeight - 1„Ç≥„Éû„ÅÆÈ´ò„ÅïÔºàURLÊåáÂÆöÊôÇÔºâ
         * @param {number} frames - „Ç≥„ÉûÊï∞ÔºàURLÊåáÂÆöÊôÇÔºâ
         * @param {string} direction - 'vertical'ÔºàÁ∏¶Ôºâ„Åæ„Åü„ÅØ'horizontal'ÔºàÊ®™Ôºâ„ÄÅ„Éá„Éï„Ç©„É´„Éà='vertical'
         */
        function setDiceSpriteSheet(urlOrConfig, frameWidth, frameHeight, frames, direction = 'vertical') {
            if (urlOrConfig === null) {
                // „Çπ„Éó„É©„Ç§„Éà„Ç∑„Éº„Éà„Çí„ÇØ„É™„Ç¢
                gameState.diceSpriteSheet = null;
                spriteImage = null;
                spriteImageLoaded = false;
                return;
            }
            
            let config;
            if (typeof urlOrConfig === 'string') {
                // Á∞°ÊòìÂΩ¢Âºè: setDiceSpriteSheet('url', 60, 60, 6)
                config = {
                    url: urlOrConfig,
                    frameWidth: frameWidth,
                    frameHeight: frameHeight,
                    frames: frames,
                    direction: direction
                };
            } else {
                // „Ç™„Éñ„Ç∏„Çß„ÇØ„ÉàÂΩ¢Âºè
                config = {
                    url: urlOrConfig.url,
                    frameWidth: urlOrConfig.frameWidth,
                    frameHeight: urlOrConfig.frameHeight,
                    frames: urlOrConfig.frames,
                    direction: urlOrConfig.direction || 'vertical'
                };
            }
            
            gameState.diceSpriteSheet = config;
            
            // ÁîªÂÉè„ÇíË™≠„ÅøËæº„ÇÄ
            spriteImage = new Image();
            spriteImageLoaded = false;
            spriteImage.onload = () => {
                spriteImageLoaded = true;
                console.log('‚úÖ „Çπ„Éó„É©„Ç§„Éà„Ç∑„Éº„ÉàË™≠„ÅøËæº„ÅøÂÆå‰∫Ü:', config.url);
            };
            spriteImage.onerror = () => {
                console.error('‚ùå „Çπ„Éó„É©„Ç§„Éà„Ç∑„Éº„ÉàË™≠„ÅøËæº„ÅøÂ§±Êïó:', config.url);
                gameState.diceSpriteSheet = null;
                spriteImage = null;
            };
            spriteImage.src = config.url;
        }
        
        /**
         * „Çµ„Ç§„Ç≥„É≠„ÅÆÊï∞„ÇíË®≠ÂÆö
         * @param {number} count - „Çµ„Ç§„Ç≥„É≠„ÅÆÊï∞
         */
        function setDiceCount(count) {
            if (isRolling) return;
            gameState.diceCount = count;
            resetDices();
        }
        
        /**
         * ÊåáÂÆö„Åó„ÅüÁõÆ„Åß„Çµ„Ç§„Ç≥„É≠„ÇíÊåØ„Çã
         * @param {string} direction - 'bottom', 'top', 'left', 'right'
         * @param {Array} values - Âá∫„Åó„Åü„ÅÑÁõÆ„ÅÆÈÖçÂàó [3, 5, 2]
         */
        function rollWithValues(direction, values) {
            if (isRolling) return;
            isRolling = true;
            shonbenRoute = false;
            shonbenDiceIds = [];
            
            resultDisplay.classList.remove('show', 'shonben');
            
            dices.forEach((d, i) => {
                const targetValue = values[i] || null;
                d.roll(direction, false, targetValue, false);
            });
            
            startResultCheck();
        }
        
        /**
         * ÈÄöÂ∏∏„ÅÆ„Çµ„Ç§„Ç≥„É≠ÊåØ„ÇäÔºà„É©„É≥„ÉÄ„É†Ôºâ
         * @param {string} direction - 'bottom', 'top', 'left', 'right'
         */
        function rollDice(direction) {
            startRoll(direction, 'normal');
        }
        
        /**
         * Âº∑Âà∂„Ç∑„Éß„É≥„Éô„É≥
         * @param {string} direction - 'bottom', 'top', 'left', 'right'
         */
        function rollShonben(direction) {
            startRoll(direction, 'force-shonben');
        }

        // ========================================
        // ÂÜÖÈÉ®Èñ¢Êï∞
        // ========================================
        
        function startResultCheck() {
            const checkStatus = setInterval(() => {
                if (dices.every(d => d.isStopped)) {
                    clearInterval(checkStatus);
                    
                    const shonbenOccurred = dices.some(d => d.isShonben);
                    
                    if (shonbenOccurred) {
                        setTimeout(() => {
                            resultDisplay.textContent = "„Ç∑„Éß„É≥„Éô„É≥";
                            resultDisplay.classList.add('show', 'shonben');
                            isRolling = false;
                        }, 500);
                    } else {
                        const res = dices.map(d => {
                            if (gameState.diceLabels && d.displayValue >= 1 && d.displayValue <= gameState.diceLabels.length) {
                                return gameState.diceLabels[d.displayValue - 1];
                            }
                            return d.displayValue;
                        });
                        resultDisplay.textContent = res.join(" ");
                        resultDisplay.classList.add('show');
                        isRolling = false;
                    }
                }
            }, 100);
        }

        let dices = [];
        let isRolling = false;
        let shonbenRoute = false;
        let shonbenDiceIds = [];

        const canvas = document.getElementById('diceCanvas');
        const ctx = canvas.getContext('2d');
        const resultDisplay = document.getElementById('result-display');

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resize);
        resize();

        // ========================================
        // Dice„ÇØ„É©„ÇπÂÆöÁæ©
        // ========================================
        class Dice {
            constructor(id) {
                this.id = id;
                this.reset();
            }

            reset() {
                this.x = canvas.width / 2;
                this.y = canvas.height + 200;
                this.z = 0;
                this.vx = 0; this.vy = 0; this.vz = 0;
                this.gravity = 0.8;
                this.displayValue = 1;
                this.targetValue = null; 
                this.angle = 0; this.vAngle = 0;
                this.isStopped = true;
                this.isValueFixed = false;
                this.isShonben = false;
                this.fallScale = 1.0;
                this.opacity = 1.0;
                this.shakeAmount = 0;
                this.shuffleTimer = 0;
            }

            roll(direction = 'bottom', forceShonben = false, forceValue = null, isShonbenTarget = false) {
                this.isStopped = false;
                this.isValueFixed = false;
                this.isShonben = false;
                this.fallScale = 1.0;
                this.opacity = 1.0;
                
                // Áöø„Å™„ÅóÊôÇ„ÅØÂº∑Âà∂ÁöÑ„Å´„Ç∑„Éß„É≥„Éô„É≥ÂØæË±°„Å´„Åô„ÇãÔºàÊúÄÂÑ™ÂÖàÔºâ
                if (!gameState.bowlEnabled) {
                    isShonbenTarget = true;
                    forceValue = null;  // ÊåáÂÆöÂÄ§„ÇíÁÑ°Ë¶ñ
                }
                
                this.targetValue = forceValue;
                
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;

                let targetX, targetY;
                
                if (forceShonben || isShonbenTarget) {
                    const angle = Math.random() * Math.PI * 2;
                    const r = RADIUS + 50 + Math.random() * 100;
                    targetX = centerX + Math.cos(angle) * r;
                    targetY = centerY + Math.sin(angle) * r;
                } else {
                    const variance = (forceValue !== null) ? FIXED_VARIANCE : NORMAL_VARIANCE;
                    const angle = Math.random() * Math.PI * 2;
                    const r = Math.pow(Math.random(), 2.0) * variance;
                    targetX = centerX + Math.cos(angle) * r;
                    targetY = centerY + Math.sin(angle) * r;
                }
                
                let startX, startY, baseVx, baseVy;
                const throwDistance = 420;
                
                switch(direction) {
                    case 'top':
                        startX = centerX + (Math.random() - 0.5) * 60;
                        startY = centerY - throwDistance;
                        baseVx = (targetX - startX) / 35;
                        baseVy = (targetY - startY) / 35 + 2;
                        break;
                    case 'left':
                        startX = centerX - throwDistance;
                        startY = centerY + (Math.random() - 0.5) * 60;
                        baseVx = (targetX - startX) / 35 + 2;
                        baseVy = (targetY - startY) / 35;
                        break;
                    case 'right':
                        startX = centerX + throwDistance;
                        startY = centerY + (Math.random() - 0.5) * 60;
                        baseVx = (targetX - startX) / 35 - 2;
                        baseVy = (targetY - startY) / 35;
                        break;
                    case 'bottom':
                    default:
                        startX = centerX + (Math.random() - 0.5) * 60;
                        startY = centerY + throwDistance;
                        baseVx = (targetX - startX) / 35;
                        baseVy = (targetY - startY) / 35 - 2;
                        break;
                }
                
                this.x = startX;
                this.y = startY;

                if (forceShonben || isShonbenTarget) {
                    this.z = 80;
                    this.vx = baseVx + (Math.random() - 0.5) * 3;
                    this.vy = baseVy + (Math.random() - 0.5) * 3;
                    this.vz = 4 + Math.random() * 2; 
                    this.vAngle = (Math.random() - 0.5) * 4;
                    this.gravity = 0.6;
                } else {
                    this.z = 200; 
                    this.vx = baseVx + (Math.random() - 0.5) * 0.5;
                    this.vy = baseVy + (Math.random() - 0.5) * 0.5;
                    this.vz = 3.5 + Math.random() * 1.5;
                    this.vAngle = (Math.random() - 0.5) * 2;
                    this.gravity = 0.75;
                }
                
                this.shuffleTimer = 0;
            }

            update() {
                if (this.isStopped) return;

                this.x += this.vx;
                this.y += this.vy;
                this.z += this.vz;
                this.vz -= this.gravity; 

                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                const dx = this.x - centerX;
                const dy = this.y - centerY;
                const dist = Math.sqrt(dx*dx + dy*dy);

                if (this.z <= 0) {
                    this.z = 0;
                    
                    const isShonbenDice = shonbenDiceIds.includes(this.id);
                    if (dist > RADIUS || isShonbenDice) {
                        if (!this.isShonben) {
                            this.isShonben = true;
                            this.vz = 0;
                            this.vx *= 1.2;
                            this.vy = 8;
                            this.gravity = 0.3;
                        }
                    } else {
                        if (!this.isValueFixed) {
                            this.isValueFixed = true;
                            this.displayValue = this.targetValue || (Math.floor(Math.random() * gameState.diceFaces) + 1);
                            this.shakeAmount = 15;
                        }
                        this.vz *= -0.25;
                        this.vx *= 0.6;
                        this.vy *= 0.6;
                        this.vAngle *= 0.5;
                    }
                }

                if (this.isShonben) {
                    this.vy += 0.3;
                    this.fallScale *= 0.985;
                    this.opacity *= 0.97;
                    if (this.y > canvas.height + 100 || this.opacity < 0.05) {
                        this.isStopped = true;
                    }
                }

                if (!this.isValueFixed) {
                    this.angle += this.vAngle;
                    this.shuffleTimer++;
                    if (this.shuffleTimer % 4 === 0) {
                        this.displayValue = Math.floor(Math.random() * gameState.diceFaces) + 1;
                    }
                } else {
                    this.angle *= 0.9; 
                }

                if (!this.isShonben && this.z < 80) {
                    const wallDist = dist;
                    const safeRadius = RADIUS - DICE_SIZE;
                    
                    if (wallDist > safeRadius) {
                        const nx = dx / dist;
                        const ny = dy / dist;
                        
                        const dot = this.vx * nx + this.vy * ny;
                        if (dot > 0) {
                            this.vx -= 2.5 * dot * nx;
                            this.vy -= 2.5 * dot * ny;
                            
                            this.vx *= 0.65;
                            this.vy *= 0.65;
                            
                            const pushForce = (wallDist - safeRadius) * 0.15;
                            this.vx -= nx * pushForce;
                            this.vy -= ny * pushForce;
                            
                            if (wallDist > RADIUS - DICE_SIZE/2) {
                                const overlap = wallDist - (RADIUS - DICE_SIZE/2);
                                this.x -= nx * overlap;
                                this.y -= ny * overlap;
                            }
                        }
                    }
                }

                dices.forEach(other => {
                    if (other === this || other.isStopped || other.isShonben) return;
                    const dx_d = this.x - other.x;
                    const dy_d = this.y - other.y;
                    const d2 = dx_d*dx_d + dy_d*dy_d;
                    const minDist = DICE_SIZE * 0.9;
                    if (d2 < minDist * minDist && Math.abs(this.z - other.z) < 25) {
                        const d = Math.sqrt(d2) || 1;
                        const nx = dx_d / d;
                        const ny = dy_d / d;
                        const pushForce = 0.5;
                        this.vx += nx * pushForce;
                        this.vy += ny * pushForce;
                        other.vx -= nx * pushForce;
                        other.vy -= ny * pushForce;
                        
                        const overlap = minDist - d;
                        this.x += nx * overlap * 0.5;
                        this.y += ny * overlap * 0.5;
                        other.x -= nx * overlap * 0.5;
                        other.y -= ny * overlap * 0.5;
                    }
                });

                if (!this.isShonben && this.isValueFixed) {
                    const speed = Math.sqrt(this.vx*this.vx + this.vy*this.vy);
                    if (speed < 0.15 && this.z < 1) {
                        this.vx = 0;
                        this.vy = 0;
                        this.vz = 0;
                        this.z = 0;
                        this.isStopped = true;
                    }
                }
            }

            draw() {
                if (this.opacity <= 0) return;
                ctx.globalAlpha = this.opacity;

                if (!this.isShonben) {
                    ctx.save();
                    ctx.translate(this.x, this.y);
                    const sScale = (1 + this.z / 200) * this.fallScale;
                    ctx.scale(sScale, sScale);
                    ctx.fillStyle = "rgba(0,0,0,0.15)";
                    ctx.beginPath();
                    ctx.roundRect(-DICE_SIZE/2 + 4, -DICE_SIZE/2 + 4, DICE_SIZE, DICE_SIZE, 12);
                    ctx.fill();
                    ctx.restore();
                }

                ctx.save();
                ctx.translate(this.x, this.y - this.z);
                if (this.shakeAmount > 0) {
                    ctx.translate((Math.random()-0.5)*this.shakeAmount, (Math.random()-0.5)*this.shakeAmount);
                    this.shakeAmount *= 0.85;
                }
                ctx.rotate(this.angle);
                const drawScale = (1 + this.z / 300) * this.fallScale;
                ctx.scale(drawScale, drawScale);
                this.drawDiceFace(this.displayValue);
                ctx.restore();

                ctx.globalAlpha = 1.0;
            }

            drawDiceFace(val) {
                const s = DICE_SIZE;
                const r = 10;
                
                ctx.fillStyle = "#cbd5e1";
                ctx.beginPath();
                ctx.roundRect(-s/2, -s/2 + 5, s, s, r);
                ctx.fill();
                
                ctx.fillStyle = "#ffffff";
                ctx.beginPath();
                ctx.roundRect(-s/2, -s/2, s, s, r);
                ctx.fill();
                
                this.drawNumber(val);
            }

            drawNumber(val) {
                const s = DICE_SIZE;
                
                // „Çπ„Éó„É©„Ç§„Éà„Ç∑„Éº„Éà„ÅåË®≠ÂÆö„Åï„Çå„Å¶„ÅÑ„ÇãÂ†¥Âêà
                if (gameState.diceSpriteSheet && spriteImageLoaded && spriteImage) {
                    const config = gameState.diceSpriteSheet;
                    const frameIndex = val - 1;  // 1Âßã„Åæ„Çä„Çí0Âßã„Åæ„Çä„Å´Â§âÊèõ
                    
                    if (frameIndex >= 0 && frameIndex < config.frames) {
                        let sx, sy;
                        if (config.direction === 'horizontal') {
                            // Ê®™‰∏¶„Å≥
                            sx = frameIndex * config.frameWidth;
                            sy = 0;
                        } else {
                            // Á∏¶‰∏¶„Å≥Ôºà„Éá„Éï„Ç©„É´„ÉàÔºâ
                            sx = 0;
                            sy = frameIndex * config.frameHeight;
                        }
                        
                        // „Çπ„Éó„É©„Ç§„Éà„Ç∑„Éº„Éà„Åã„ÇâÂàá„ÇäÂèñ„Å£„Å¶ÊèèÁîª
                        ctx.drawImage(
                            spriteImage,
                            sx, sy, config.frameWidth, config.frameHeight,  // „ÇΩ„Éº„ÇπÔºàÂàá„ÇäÂèñ„ÇäÔºâ
                            -s/2, -s/2, s, s  // ÊèèÁîªÂÖà
                        );
                        return;
                    }
                }
                
                // „Ç´„Çπ„Çø„É†ÊñáÂ≠ó„Åæ„Åü„ÅØ„Éá„Éï„Ç©„É´„Éà„ÅÆÊï∞Â≠óÊèèÁîª
                ctx.fillStyle = val === 1 ? "#e11d48" : "#1e293b";
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                
                let displayText = val;
                if (gameState.diceLabels && val >= 1 && val <= gameState.diceLabels.length) {
                    displayText = gameState.diceLabels[val - 1];
                }
                
                ctx.font = `bold ${s * 0.7}px 'Arial'`;
                ctx.fillText(displayText, 0, 0);
            }
        }

        // ========================================
        // ÂàùÊúüÂåñ
        // ========================================
        
        const bowlElement = document.getElementById('bowl-bg');
        setBowl(gameState.bowlEnabled);
        bowlElement.style.width = gameState.bowlRadius * 2 + 'px';
        bowlElement.style.height = gameState.bowlRadius * 2 + 'px';

        resultDisplay.textContent = Array(gameState.diceCount).fill('?').join(' ');

        function resetDices() {
            dices = [];
            for (let i = 0; i < gameState.diceCount; i++) {
                dices.push(new Dice(i));
            }
            resultDisplay.textContent = Array(gameState.diceCount).fill('?').join(' ');
            resultDisplay.classList.remove('show', 'shonben');
        }

        for (let i = 0; i < gameState.diceCount; i++) {
            dices.push(new Dice(i));
        }

        function startRoll(direction, mode = 'normal') {
            if (isRolling) return;
            isRolling = true;
            shonbenRoute = false;
            shonbenDiceIds = [];
            
            resultDisplay.classList.remove('show', 'shonben');
            
            let targetValues = new Array(gameState.diceCount).fill(null);
            
            if (mode === 'force-shonben') {
                shonbenRoute = true;
                const minCount = Math.min(gameState.shonbenMinDice, gameState.diceCount);
                const maxCount = Math.min(gameState.shonbenMaxDice, gameState.diceCount);
                const shonbenCount = Math.floor(Math.random() * (maxCount - minCount + 1)) + minCount;
                
                const allIds = dices.map((_, i) => i);
                for (let i = allIds.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [allIds[i], allIds[j]] = [allIds[j], allIds[i]];
                }
                shonbenDiceIds = allIds.slice(0, shonbenCount);
            } else if (mode === 'force-pin') {
                targetValues = new Array(gameState.diceCount).fill(1);
            } else {
                if (!gameState.bowlEnabled) {
                    shonbenRoute = true;
                    shonbenDiceIds = dices.map((_, i) => i);
                } else {
                    if (Math.random() < SHONBEN_CHANCE) {
                        shonbenRoute = true;
                        const minCount = Math.min(gameState.shonbenMinDice, gameState.diceCount);
                        const maxCount = Math.min(gameState.shonbenMaxDice, gameState.diceCount);
                        const shonbenCount = Math.floor(Math.random() * (maxCount - minCount + 1)) + minCount;
                        
                        const allIds = dices.map((_, i) => i);
                        for (let i = allIds.length - 1; i > 0; i--) {
                            const j = Math.floor(Math.random() * (i + 1));
                            [allIds[i], allIds[j]] = [allIds[j], allIds[i]];
                        }
                        shonbenDiceIds = allIds.slice(0, shonbenCount);
                    }
                }
            }

            dices.forEach((d, i) => {
                const isShonbenTarget = shonbenDiceIds.includes(i);
                d.roll(direction, (mode === 'force-shonben'), targetValues[i], isShonbenTarget);
            });

            const checkStatus = setInterval(() => {
                if (dices.every(d => d.isStopped)) {
                    clearInterval(checkStatus);
                    
                    const shonbenOccurred = dices.some(d => d.isShonben);
                    
                    if (shonbenOccurred) {
                        setTimeout(() => {
                            resultDisplay.textContent = "„Ç∑„Éß„É≥„Éô„É≥";
                            resultDisplay.classList.add('show', 'shonben');
                            isRolling = false;
                        }, 500);
                    } else {
                        const res = dices.map(d => {
                            if (gameState.diceLabels && d.displayValue >= 1 && d.displayValue <= gameState.diceLabels.length) {
                                return gameState.diceLabels[d.displayValue - 1];
                            }
                            return d.displayValue;
                        });
                        resultDisplay.textContent = res.join(" ");
                        resultDisplay.classList.add('show');
                        isRolling = false;
                    }
                }
            }, 100);
        }

        function animate() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            const sortedDices = [...dices].sort((a, b) => a.z - b.z);
            dices.forEach(d => d.update());
            sortedDices.forEach(d => d.draw());
            requestAnimationFrame(animate);
        }

        animate();

        // ========================================
        // „Ç≥„É≥„ÇΩ„Éº„É´„ÅßAPI„Çí‰Ωø„Åà„Çã„Çà„ÅÜ„Å´„Ç∞„É≠„Éº„Éê„É´„Å´ÂÖ¨Èñã
        // ========================================
        window.DiceRoller = {
            setBowl,
            setDiceFaces,
            setDiceLabels,
            setDiceSpriteSheet,
            setDiceCount,
            rollDice,
            rollWithValues,
            rollShonben
        };

        console.log('üé≤ Dice Roller API loaded!');
        console.log('‰ΩøÁî®‰æã: DiceRoller.rollDice("bottom")');
        console.log('„Çπ„Éó„É©„Ç§„Éà„Ç∑„Éº„Éà: DiceRoller.setDiceSpriteSheet("dice.png", 60, 60, 6)');
        console.log('Ë©≥Á¥∞: HTML„Ç≥„É°„É≥„ÉàÂèÇÁÖß');
    </script>
</body>
</html>